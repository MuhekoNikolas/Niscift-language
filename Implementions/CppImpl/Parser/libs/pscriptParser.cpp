
// Generated from ./pscriptParser.g4 by ANTLR 4.13.0


#include "pscriptParserListener.h"
#include "pscriptParserVisitor.h"

#include "pscriptParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct PscriptParserStaticData final {
  PscriptParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  PscriptParserStaticData(const PscriptParserStaticData&) = delete;
  PscriptParserStaticData(PscriptParserStaticData&&) = delete;
  PscriptParserStaticData& operator=(const PscriptParserStaticData&) = delete;
  PscriptParserStaticData& operator=(PscriptParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag pscriptparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
PscriptParserStaticData *pscriptparserParserStaticData = nullptr;

void pscriptparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (pscriptparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(pscriptparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<PscriptParserStaticData>(
    std::vector<std::string>{
      "root", "single_input", "file_input", "eval_input", "stmt", "compound_stmt", 
      "suite", "decorator", "elif_clause", "else_clause", "finally_clause", 
      "with_item", "except_clause", "classdef", "funcdef", "typedargslist", 
      "args", "kwargs", "def_parameters", "def_parameter", "named_parameter", 
      "simple_stmt", "small_stmt", "variable_def", "variable_def_name", 
      "variable_def_comma_name", "from_where", "comma_name", "comma_test", 
      "variable_def_consts", "variable_def_consts_with_colon", "testlist_star_expr", 
      "star_expr", "assign_part", "exprlist", "import_as_names", "import_as_name", 
      "name_as_names", "name_as_name", "test", "varargslist", "vardef_parameters", 
      "vardef_parameter", "varargs", "varkwargs", "logical_test", "comparison", 
      "expr", "atom", "dictmaker", "setmaker", "testlist", "dotted_name", 
      "name", "bool", "number", "integer", "yield_expr", "yield_arg", "trailer", 
      "arguments", "arglist", "argument", "subscriptlist", "subscript", 
      "sliceop", "comp_for", "comp_iter"
    },
    std::vector<std::string>{
      "", "", "", "", "'def'", "'return'", "'raise'", "'from'", "'import'", 
      "'nonlocal'", "'as'", "'global'", "'assert'", "'if'", "'elif'", "'else'", 
      "'while'", "'for'", "'in'", "'try'", "", "'finally'", "'with'", "'except'", 
      "'lambda'", "'or'", "'and'", "'not'", "'is'", "'class'", "'yield'", 
      "'del'", "'pass'", "'continue'", "'break'", "'async'", "'await'", 
      "'exec'", "'True'", "'False'", "'var'", "'const'", "'let'", "'.'", 
      "'`'", "'*'", "','", "':'", "';'", "'**'", "'='", "'|'", "'^'", "'&'", 
      "'<<'", "'>>'", "'+'", "'-'", "'/'", "'%'", "'//'", "'~'", "'<'", 
      "'>'", "'=='", "'>='", "'<='", "'<>'", "'!='", "'@'", "'->'", "'+='", 
      "'-='", "'*='", "'/='", "'%='", "'^='", "'**='", "'//='", "", "", 
      "", "", "", "", "", "'('", "')'", "'{'", "'}'", "'['", "']'"
    },
    std::vector<std::string>{
      "", "INDENT", "DEDENT", "LINE_BREAK", "DEF", "RETURN", "RAISE", "FROM", 
      "IMPORT", "NONLOCAL", "AS", "GLOBAL", "ASSERT", "IF", "ELIF", "ELSE", 
      "WHILE", "FOR", "IN", "TRY", "NONE", "FINALLY", "WITH", "EXCEPT", 
      "LAMBDA", "OR", "AND", "NOT", "IS", "CLASS", "YIELD", "DEL", "PASS", 
      "CONTINUE", "BREAK", "ASYNC", "AWAIT", "EXEC", "TRUE", "FALSE", "VAR", 
      "CONST", "LET", "DOT", "REVERSE_QUOTE", "STAR", "COMMA", "COLON", 
      "SEMI_COLON", "POWER", "ASSIGN", "OR_OP", "XOR", "AND_OP", "LEFT_SHIFT", 
      "RIGHT_SHIFT", "ADD", "MINUS", "DIV", "MOD", "IDIV", "NOT_OP", "LESS_THAN", 
      "GREATER_THAN", "EQUALS", "GT_EQ", "LT_EQ", "NOT_EQ_1", "NOT_EQ_2", 
      "AT", "ARROW", "ADD_ASSIGN", "SUB_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", 
      "MOD_ASSIGN", "XOR_ASSIGN", "POWER_ASSIGN", "IDIV_ASSIGN", "STRING", 
      "DECIMAL_INTEGER", "OCT_INTEGER", "HEX_INTEGER", "BIN_INTEGER", "IMAG_NUMBER", 
      "FLOAT_NUMBER", "OPEN_PAREN", "CLOSE_PAREN", "OPEN_BRACE", "CLOSE_BRACE", 
      "OPEN_BRACKET", "CLOSE_BRACKET", "NAME", "LINE_JOIN", "NEWLINE", "WS", 
      "COMMENT"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,96,903,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,1,0,1,0,1,0,3,0,140,8,0,1,
  	0,1,0,1,1,1,1,1,1,1,1,1,1,3,1,149,8,1,1,2,1,2,4,2,153,8,2,11,2,12,2,154,
  	1,3,1,3,5,3,159,8,3,10,3,12,3,162,9,3,1,4,1,4,3,4,166,8,4,1,5,1,5,1,5,
  	1,5,1,5,5,5,173,8,5,10,5,12,5,176,9,5,1,5,3,5,179,8,5,1,5,1,5,1,5,1,5,
  	1,5,3,5,186,8,5,1,5,3,5,189,8,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,198,8,
  	5,1,5,1,5,1,5,1,5,4,5,204,8,5,11,5,12,5,205,1,5,3,5,209,8,5,1,5,3,5,212,
  	8,5,1,5,3,5,215,8,5,1,5,3,5,218,8,5,1,5,1,5,1,5,1,5,5,5,224,8,5,10,5,
  	12,5,227,9,5,1,5,1,5,1,5,1,5,5,5,233,8,5,10,5,12,5,236,9,5,1,5,1,5,5,
  	5,240,8,5,10,5,12,5,243,9,5,1,5,3,5,246,8,5,1,6,1,6,1,6,1,6,4,6,252,8,
  	6,11,6,12,6,253,1,6,1,6,3,6,258,8,6,1,7,1,7,1,7,1,7,3,7,264,8,7,1,7,3,
  	7,267,8,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,10,1,10,1,10,
  	1,10,1,11,1,11,1,11,3,11,287,8,11,1,12,1,12,1,12,1,12,3,12,293,8,12,3,
  	12,295,8,12,1,12,1,12,1,12,1,13,1,13,1,13,1,13,3,13,304,8,13,1,13,3,13,
  	307,8,13,1,13,1,13,1,13,1,14,3,14,313,8,14,1,14,1,14,1,14,1,14,3,14,319,
  	8,14,1,14,1,14,1,14,1,14,1,15,1,15,1,15,3,15,328,8,15,1,15,1,15,1,15,
  	3,15,333,8,15,1,15,1,15,3,15,337,8,15,1,15,3,15,340,8,15,1,15,3,15,343,
  	8,15,1,15,1,15,3,15,347,8,15,3,15,349,8,15,1,16,1,16,1,16,1,17,1,17,1,
  	17,1,18,1,18,1,18,5,18,360,8,18,10,18,12,18,363,9,18,1,19,1,19,1,19,3,
  	19,368,8,19,1,19,3,19,371,8,19,1,20,1,20,1,20,3,20,376,8,20,1,21,1,21,
  	1,21,5,21,381,8,21,10,21,12,21,384,9,21,1,21,3,21,387,8,21,1,21,1,21,
  	1,22,1,22,3,22,393,8,22,1,22,1,22,1,22,3,22,398,8,22,1,22,1,22,1,22,1,
  	22,1,22,1,22,1,22,1,22,1,22,3,22,409,8,22,1,22,1,22,3,22,413,8,22,1,22,
  	1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,3,22,427,8,22,
  	1,22,1,22,1,22,1,22,1,22,1,22,3,22,435,8,22,1,22,1,22,3,22,439,8,22,1,
  	23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,
  	23,1,23,1,23,1,23,3,23,459,8,23,1,24,1,24,1,24,1,24,1,24,5,24,466,8,24,
  	10,24,12,24,469,9,24,1,24,1,24,3,24,473,8,24,1,25,1,25,1,25,5,25,478,
  	8,25,10,25,12,25,481,9,25,1,26,5,26,484,8,26,10,26,12,26,487,9,26,1,26,
  	1,26,4,26,491,8,26,11,26,12,26,492,3,26,495,8,26,1,27,1,27,1,27,5,27,
  	500,8,27,10,27,12,27,503,9,27,1,28,1,28,1,28,1,28,1,28,3,28,510,8,28,
  	3,28,512,8,28,1,29,1,29,1,30,1,30,1,31,1,31,1,31,4,31,521,8,31,11,31,
  	12,31,522,1,31,3,31,526,8,31,1,31,3,31,529,8,31,1,32,1,32,1,32,1,33,1,
  	33,1,33,3,33,537,8,33,1,34,1,34,1,34,5,34,542,8,34,10,34,12,34,545,9,
  	34,1,34,3,34,548,8,34,1,35,1,35,1,35,5,35,553,8,35,10,35,12,35,556,9,
  	35,1,35,3,35,559,8,35,1,36,1,36,1,36,3,36,564,8,36,1,37,1,37,1,37,5,37,
  	569,8,37,10,37,12,37,572,9,37,1,38,1,38,1,38,3,38,577,8,38,1,39,1,39,
  	1,39,1,39,1,39,1,39,3,39,585,8,39,1,39,1,39,3,39,589,8,39,1,39,1,39,3,
  	39,593,8,39,1,40,1,40,1,40,3,40,598,8,40,1,40,1,40,1,40,3,40,603,8,40,
  	1,40,1,40,3,40,607,8,40,1,40,3,40,610,8,40,1,40,3,40,613,8,40,1,40,1,
  	40,3,40,617,8,40,3,40,619,8,40,1,41,1,41,1,41,5,41,624,8,41,10,41,12,
  	41,627,9,41,1,42,1,42,1,42,3,42,632,8,42,1,42,3,42,635,8,42,1,43,1,43,
  	1,43,1,44,1,44,1,44,1,45,1,45,1,45,1,45,3,45,647,8,45,1,45,1,45,1,45,
  	1,45,1,45,1,45,5,45,655,8,45,10,45,12,45,658,9,45,1,46,1,46,1,46,1,46,
  	1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,3,46,672,8,46,1,46,1,46,1,46,
  	3,46,677,8,46,3,46,679,8,46,1,46,5,46,682,8,46,10,46,12,46,685,9,46,1,
  	47,1,47,3,47,689,8,47,1,47,1,47,5,47,693,8,47,10,47,12,47,696,9,47,1,
  	47,1,47,3,47,700,8,47,1,47,1,47,1,47,5,47,705,8,47,10,47,12,47,708,9,
  	47,1,48,1,48,1,48,3,48,713,8,48,1,48,1,48,1,48,3,48,718,8,48,1,48,1,48,
  	1,48,3,48,723,8,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,3,48,733,8,
  	48,1,48,1,48,1,48,1,48,3,48,739,8,48,1,48,1,48,1,48,4,48,744,8,48,11,
  	48,12,48,745,3,48,748,8,48,1,49,1,49,1,49,1,49,1,49,1,49,3,49,756,8,49,
  	1,49,1,49,1,49,1,49,1,49,1,49,1,49,3,49,765,8,49,5,49,767,8,49,10,49,
  	12,49,770,9,49,1,49,3,49,773,8,49,1,50,1,50,1,51,1,51,1,51,5,51,780,8,
  	51,10,51,12,51,783,9,51,1,52,1,52,1,52,1,52,1,52,1,52,5,52,791,8,52,10,
  	52,12,52,794,9,52,1,53,1,53,3,53,798,8,53,1,54,1,54,1,55,1,55,1,55,3,
  	55,805,8,55,1,56,1,56,1,57,1,57,3,57,811,8,57,1,58,1,58,1,59,1,59,1,59,
  	3,59,818,8,59,1,59,3,59,821,8,59,1,60,1,60,3,60,825,8,60,1,60,1,60,1,
  	60,1,60,1,60,3,60,832,8,60,1,61,1,61,1,61,5,61,837,8,61,10,61,12,61,840,
  	9,61,1,61,3,61,843,8,61,1,62,1,62,1,62,3,62,848,8,62,1,62,1,62,3,62,852,
  	8,62,1,63,1,63,1,63,5,63,857,8,63,10,63,12,63,860,9,63,1,63,3,63,863,
  	8,63,1,64,1,64,1,64,3,64,868,8,64,1,64,3,64,871,8,64,3,64,873,8,64,1,
  	64,1,64,3,64,877,8,64,1,64,3,64,880,8,64,3,64,882,8,64,1,65,1,65,3,65,
  	886,8,65,1,66,1,66,1,66,1,66,1,66,3,66,893,8,66,1,67,1,67,1,67,1,67,3,
  	67,899,8,67,3,67,901,8,67,1,67,0,4,90,92,94,104,68,0,2,4,6,8,10,12,14,
  	16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,
  	62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
  	106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,0,9,1,1,3,
  	3,1,0,40,42,2,0,40,40,42,42,2,0,50,50,71,78,2,0,56,57,61,61,3,0,45,45,
  	49,49,56,60,1,0,38,39,1,0,80,83,2,0,45,45,49,49,1006,0,139,1,0,0,0,2,
  	148,1,0,0,0,4,152,1,0,0,0,6,156,1,0,0,0,8,165,1,0,0,0,10,245,1,0,0,0,
  	12,257,1,0,0,0,14,259,1,0,0,0,16,270,1,0,0,0,18,275,1,0,0,0,20,279,1,
  	0,0,0,22,283,1,0,0,0,24,288,1,0,0,0,26,299,1,0,0,0,28,312,1,0,0,0,30,
  	348,1,0,0,0,32,350,1,0,0,0,34,353,1,0,0,0,36,356,1,0,0,0,38,370,1,0,0,
  	0,40,372,1,0,0,0,42,377,1,0,0,0,44,438,1,0,0,0,46,458,1,0,0,0,48,460,
  	1,0,0,0,50,474,1,0,0,0,52,494,1,0,0,0,54,496,1,0,0,0,56,504,1,0,0,0,58,
  	513,1,0,0,0,60,515,1,0,0,0,62,528,1,0,0,0,64,530,1,0,0,0,66,533,1,0,0,
  	0,68,538,1,0,0,0,70,549,1,0,0,0,72,560,1,0,0,0,74,565,1,0,0,0,76,573,
  	1,0,0,0,78,592,1,0,0,0,80,618,1,0,0,0,82,620,1,0,0,0,84,634,1,0,0,0,86,
  	636,1,0,0,0,88,639,1,0,0,0,90,646,1,0,0,0,92,659,1,0,0,0,94,699,1,0,0,
  	0,96,747,1,0,0,0,98,755,1,0,0,0,100,774,1,0,0,0,102,776,1,0,0,0,104,784,
  	1,0,0,0,106,797,1,0,0,0,108,799,1,0,0,0,110,804,1,0,0,0,112,806,1,0,0,
  	0,114,808,1,0,0,0,116,812,1,0,0,0,118,820,1,0,0,0,120,831,1,0,0,0,122,
  	833,1,0,0,0,124,851,1,0,0,0,126,853,1,0,0,0,128,881,1,0,0,0,130,883,1,
  	0,0,0,132,887,1,0,0,0,134,900,1,0,0,0,136,140,3,2,1,0,137,140,3,4,2,0,
  	138,140,3,6,3,0,139,136,1,0,0,0,139,137,1,0,0,0,139,138,1,0,0,0,139,140,
  	1,0,0,0,140,141,1,0,0,0,141,142,5,0,0,1,142,1,1,0,0,0,143,149,5,3,0,0,
  	144,149,3,42,21,0,145,146,3,10,5,0,146,147,5,3,0,0,147,149,1,0,0,0,148,
  	143,1,0,0,0,148,144,1,0,0,0,148,145,1,0,0,0,149,3,1,0,0,0,150,153,5,3,
  	0,0,151,153,3,8,4,0,152,150,1,0,0,0,152,151,1,0,0,0,153,154,1,0,0,0,154,
  	152,1,0,0,0,154,155,1,0,0,0,155,5,1,0,0,0,156,160,3,102,51,0,157,159,
  	5,3,0,0,158,157,1,0,0,0,159,162,1,0,0,0,160,158,1,0,0,0,160,161,1,0,0,
  	0,161,7,1,0,0,0,162,160,1,0,0,0,163,166,3,42,21,0,164,166,3,10,5,0,165,
  	163,1,0,0,0,165,164,1,0,0,0,166,9,1,0,0,0,167,168,5,13,0,0,168,169,3,
  	78,39,0,169,170,5,47,0,0,170,174,3,12,6,0,171,173,3,16,8,0,172,171,1,
  	0,0,0,173,176,1,0,0,0,174,172,1,0,0,0,174,175,1,0,0,0,175,178,1,0,0,0,
  	176,174,1,0,0,0,177,179,3,18,9,0,178,177,1,0,0,0,178,179,1,0,0,0,179,
  	246,1,0,0,0,180,181,5,16,0,0,181,182,3,78,39,0,182,183,5,47,0,0,183,185,
  	3,12,6,0,184,186,3,18,9,0,185,184,1,0,0,0,185,186,1,0,0,0,186,246,1,0,
  	0,0,187,189,5,35,0,0,188,187,1,0,0,0,188,189,1,0,0,0,189,190,1,0,0,0,
  	190,191,5,17,0,0,191,192,3,68,34,0,192,193,5,18,0,0,193,194,3,102,51,
  	0,194,195,5,47,0,0,195,197,3,12,6,0,196,198,3,18,9,0,197,196,1,0,0,0,
  	197,198,1,0,0,0,198,246,1,0,0,0,199,200,5,19,0,0,200,201,5,47,0,0,201,
  	214,3,12,6,0,202,204,3,24,12,0,203,202,1,0,0,0,204,205,1,0,0,0,205,203,
  	1,0,0,0,205,206,1,0,0,0,206,208,1,0,0,0,207,209,3,18,9,0,208,207,1,0,
  	0,0,208,209,1,0,0,0,209,211,1,0,0,0,210,212,3,20,10,0,211,210,1,0,0,0,
  	211,212,1,0,0,0,212,215,1,0,0,0,213,215,3,20,10,0,214,203,1,0,0,0,214,
  	213,1,0,0,0,215,246,1,0,0,0,216,218,5,35,0,0,217,216,1,0,0,0,217,218,
  	1,0,0,0,218,219,1,0,0,0,219,220,5,22,0,0,220,225,3,22,11,0,221,222,5,
  	46,0,0,222,224,3,22,11,0,223,221,1,0,0,0,224,227,1,0,0,0,225,223,1,0,
  	0,0,225,226,1,0,0,0,226,228,1,0,0,0,227,225,1,0,0,0,228,229,5,47,0,0,
  	229,230,3,12,6,0,230,246,1,0,0,0,231,233,3,14,7,0,232,231,1,0,0,0,233,
  	236,1,0,0,0,234,232,1,0,0,0,234,235,1,0,0,0,235,237,1,0,0,0,236,234,1,
  	0,0,0,237,246,3,26,13,0,238,240,3,14,7,0,239,238,1,0,0,0,240,243,1,0,
  	0,0,241,239,1,0,0,0,241,242,1,0,0,0,242,244,1,0,0,0,243,241,1,0,0,0,244,
  	246,3,28,14,0,245,167,1,0,0,0,245,180,1,0,0,0,245,188,1,0,0,0,245,199,
  	1,0,0,0,245,217,1,0,0,0,245,234,1,0,0,0,245,241,1,0,0,0,246,11,1,0,0,
  	0,247,258,3,42,21,0,248,249,5,3,0,0,249,251,5,1,0,0,250,252,3,8,4,0,251,
  	250,1,0,0,0,252,253,1,0,0,0,253,251,1,0,0,0,253,254,1,0,0,0,254,255,1,
  	0,0,0,255,256,5,2,0,0,256,258,1,0,0,0,257,247,1,0,0,0,257,248,1,0,0,0,
  	258,13,1,0,0,0,259,260,5,69,0,0,260,266,3,104,52,0,261,263,5,86,0,0,262,
  	264,3,122,61,0,263,262,1,0,0,0,263,264,1,0,0,0,264,265,1,0,0,0,265,267,
  	5,87,0,0,266,261,1,0,0,0,266,267,1,0,0,0,267,268,1,0,0,0,268,269,5,3,
  	0,0,269,15,1,0,0,0,270,271,5,14,0,0,271,272,3,78,39,0,272,273,5,47,0,
  	0,273,274,3,12,6,0,274,17,1,0,0,0,275,276,5,15,0,0,276,277,5,47,0,0,277,
  	278,3,12,6,0,278,19,1,0,0,0,279,280,5,21,0,0,280,281,5,47,0,0,281,282,
  	3,12,6,0,282,21,1,0,0,0,283,286,3,78,39,0,284,285,5,10,0,0,285,287,3,
  	94,47,0,286,284,1,0,0,0,286,287,1,0,0,0,287,23,1,0,0,0,288,294,5,23,0,
  	0,289,292,3,78,39,0,290,291,5,10,0,0,291,293,3,106,53,0,292,290,1,0,0,
  	0,292,293,1,0,0,0,293,295,1,0,0,0,294,289,1,0,0,0,294,295,1,0,0,0,295,
  	296,1,0,0,0,296,297,5,47,0,0,297,298,3,12,6,0,298,25,1,0,0,0,299,300,
  	5,29,0,0,300,306,3,106,53,0,301,303,5,86,0,0,302,304,3,122,61,0,303,302,
  	1,0,0,0,303,304,1,0,0,0,304,305,1,0,0,0,305,307,5,87,0,0,306,301,1,0,
  	0,0,306,307,1,0,0,0,307,308,1,0,0,0,308,309,5,47,0,0,309,310,3,12,6,0,
  	310,27,1,0,0,0,311,313,5,35,0,0,312,311,1,0,0,0,312,313,1,0,0,0,313,314,
  	1,0,0,0,314,315,5,4,0,0,315,316,3,106,53,0,316,318,5,86,0,0,317,319,3,
  	30,15,0,318,317,1,0,0,0,318,319,1,0,0,0,319,320,1,0,0,0,320,321,5,87,
  	0,0,321,322,5,47,0,0,322,323,3,12,6,0,323,29,1,0,0,0,324,325,3,36,18,
  	0,325,326,5,46,0,0,326,328,1,0,0,0,327,324,1,0,0,0,327,328,1,0,0,0,328,
  	339,1,0,0,0,329,332,3,32,16,0,330,331,5,46,0,0,331,333,3,36,18,0,332,
  	330,1,0,0,0,332,333,1,0,0,0,333,336,1,0,0,0,334,335,5,46,0,0,335,337,
  	3,34,17,0,336,334,1,0,0,0,336,337,1,0,0,0,337,340,1,0,0,0,338,340,3,34,
  	17,0,339,329,1,0,0,0,339,338,1,0,0,0,340,342,1,0,0,0,341,343,5,46,0,0,
  	342,341,1,0,0,0,342,343,1,0,0,0,343,349,1,0,0,0,344,346,3,36,18,0,345,
  	347,5,46,0,0,346,345,1,0,0,0,346,347,1,0,0,0,347,349,1,0,0,0,348,327,
  	1,0,0,0,348,344,1,0,0,0,349,31,1,0,0,0,350,351,5,45,0,0,351,352,3,40,
  	20,0,352,33,1,0,0,0,353,354,5,49,0,0,354,355,3,40,20,0,355,35,1,0,0,0,
  	356,361,3,38,19,0,357,358,5,46,0,0,358,360,3,38,19,0,359,357,1,0,0,0,
  	360,363,1,0,0,0,361,359,1,0,0,0,361,362,1,0,0,0,362,37,1,0,0,0,363,361,
  	1,0,0,0,364,367,3,40,20,0,365,366,5,50,0,0,366,368,3,78,39,0,367,365,
  	1,0,0,0,367,368,1,0,0,0,368,371,1,0,0,0,369,371,5,45,0,0,370,364,1,0,
  	0,0,370,369,1,0,0,0,371,39,1,0,0,0,372,375,3,106,53,0,373,374,5,47,0,
  	0,374,376,3,78,39,0,375,373,1,0,0,0,375,376,1,0,0,0,376,41,1,0,0,0,377,
  	382,3,44,22,0,378,379,5,48,0,0,379,381,3,44,22,0,380,378,1,0,0,0,381,
  	384,1,0,0,0,382,380,1,0,0,0,382,383,1,0,0,0,383,386,1,0,0,0,384,382,1,
  	0,0,0,385,387,5,48,0,0,386,385,1,0,0,0,386,387,1,0,0,0,387,388,1,0,0,
  	0,388,389,7,0,0,0,389,43,1,0,0,0,390,439,3,46,23,0,391,393,5,36,0,0,392,
  	391,1,0,0,0,392,393,1,0,0,0,393,394,1,0,0,0,394,395,3,96,48,0,395,397,
  	5,86,0,0,396,398,3,122,61,0,397,396,1,0,0,0,397,398,1,0,0,0,398,399,1,
  	0,0,0,399,400,5,87,0,0,400,439,1,0,0,0,401,402,5,31,0,0,402,439,3,68,
  	34,0,403,439,5,32,0,0,404,439,5,34,0,0,405,439,5,33,0,0,406,408,5,5,0,
  	0,407,409,3,102,51,0,408,407,1,0,0,0,408,409,1,0,0,0,409,439,1,0,0,0,
  	410,412,5,6,0,0,411,413,3,56,28,0,412,411,1,0,0,0,412,413,1,0,0,0,413,
  	439,1,0,0,0,414,439,3,114,57,0,415,416,5,8,0,0,416,439,3,74,37,0,417,
  	418,5,7,0,0,418,419,3,52,26,0,419,426,5,8,0,0,420,427,5,45,0,0,421,422,
  	5,86,0,0,422,423,3,70,35,0,423,424,5,87,0,0,424,427,1,0,0,0,425,427,3,
  	70,35,0,426,420,1,0,0,0,426,421,1,0,0,0,426,425,1,0,0,0,427,439,1,0,0,
  	0,428,429,5,11,0,0,429,439,3,54,27,0,430,431,5,12,0,0,431,434,3,78,39,
  	0,432,433,5,46,0,0,433,435,3,78,39,0,434,432,1,0,0,0,434,435,1,0,0,0,
  	435,439,1,0,0,0,436,437,5,9,0,0,437,439,3,54,27,0,438,390,1,0,0,0,438,
  	392,1,0,0,0,438,401,1,0,0,0,438,403,1,0,0,0,438,404,1,0,0,0,438,405,1,
  	0,0,0,438,406,1,0,0,0,438,410,1,0,0,0,438,414,1,0,0,0,438,415,1,0,0,0,
  	438,417,1,0,0,0,438,428,1,0,0,0,438,430,1,0,0,0,438,436,1,0,0,0,439,45,
  	1,0,0,0,440,441,3,60,30,0,441,442,3,48,24,0,442,443,5,48,0,0,443,459,
  	1,0,0,0,444,445,3,58,29,0,445,446,3,48,24,0,446,447,3,66,33,0,447,459,
  	1,0,0,0,448,449,3,58,29,0,449,450,3,50,25,0,450,451,3,66,33,0,451,459,
  	1,0,0,0,452,453,3,48,24,0,453,454,3,66,33,0,454,459,1,0,0,0,455,456,3,
  	50,25,0,456,457,3,66,33,0,457,459,1,0,0,0,458,440,1,0,0,0,458,444,1,0,
  	0,0,458,448,1,0,0,0,458,452,1,0,0,0,458,455,1,0,0,0,459,47,1,0,0,0,460,
  	467,3,104,52,0,461,462,5,90,0,0,462,463,3,94,47,0,463,464,5,91,0,0,464,
  	466,1,0,0,0,465,461,1,0,0,0,466,469,1,0,0,0,467,465,1,0,0,0,467,468,1,
  	0,0,0,468,472,1,0,0,0,469,467,1,0,0,0,470,471,5,43,0,0,471,473,3,48,24,
  	0,472,470,1,0,0,0,472,473,1,0,0,0,473,49,1,0,0,0,474,479,3,48,24,0,475,
  	476,5,46,0,0,476,478,3,48,24,0,477,475,1,0,0,0,478,481,1,0,0,0,479,477,
  	1,0,0,0,479,480,1,0,0,0,480,51,1,0,0,0,481,479,1,0,0,0,482,484,5,43,0,
  	0,483,482,1,0,0,0,484,487,1,0,0,0,485,483,1,0,0,0,485,486,1,0,0,0,486,
  	488,1,0,0,0,487,485,1,0,0,0,488,495,3,104,52,0,489,491,5,43,0,0,490,489,
  	1,0,0,0,491,492,1,0,0,0,492,490,1,0,0,0,492,493,1,0,0,0,493,495,1,0,0,
  	0,494,485,1,0,0,0,494,490,1,0,0,0,495,53,1,0,0,0,496,501,3,104,52,0,497,
  	498,5,46,0,0,498,500,3,104,52,0,499,497,1,0,0,0,500,503,1,0,0,0,501,499,
  	1,0,0,0,501,502,1,0,0,0,502,55,1,0,0,0,503,501,1,0,0,0,504,511,3,78,39,
  	0,505,506,5,46,0,0,506,509,3,78,39,0,507,508,5,46,0,0,508,510,3,78,39,
  	0,509,507,1,0,0,0,509,510,1,0,0,0,510,512,1,0,0,0,511,505,1,0,0,0,511,
  	512,1,0,0,0,512,57,1,0,0,0,513,514,7,1,0,0,514,59,1,0,0,0,515,516,7,2,
  	0,0,516,61,1,0,0,0,517,518,3,78,39,0,518,519,5,46,0,0,519,521,1,0,0,0,
  	520,517,1,0,0,0,521,522,1,0,0,0,522,520,1,0,0,0,522,523,1,0,0,0,523,525,
  	1,0,0,0,524,526,3,78,39,0,525,524,1,0,0,0,525,526,1,0,0,0,526,529,1,0,
  	0,0,527,529,3,102,51,0,528,520,1,0,0,0,528,527,1,0,0,0,529,63,1,0,0,0,
  	530,531,5,45,0,0,531,532,3,94,47,0,532,65,1,0,0,0,533,536,7,3,0,0,534,
  	537,3,114,57,0,535,537,3,102,51,0,536,534,1,0,0,0,536,535,1,0,0,0,537,
  	67,1,0,0,0,538,543,3,94,47,0,539,540,5,46,0,0,540,542,3,94,47,0,541,539,
  	1,0,0,0,542,545,1,0,0,0,543,541,1,0,0,0,543,544,1,0,0,0,544,547,1,0,0,
  	0,545,543,1,0,0,0,546,548,5,46,0,0,547,546,1,0,0,0,547,548,1,0,0,0,548,
  	69,1,0,0,0,549,554,3,72,36,0,550,551,5,46,0,0,551,553,3,72,36,0,552,550,
  	1,0,0,0,553,556,1,0,0,0,554,552,1,0,0,0,554,555,1,0,0,0,555,558,1,0,0,
  	0,556,554,1,0,0,0,557,559,5,46,0,0,558,557,1,0,0,0,558,559,1,0,0,0,559,
  	71,1,0,0,0,560,563,3,106,53,0,561,562,5,10,0,0,562,564,3,106,53,0,563,
  	561,1,0,0,0,563,564,1,0,0,0,564,73,1,0,0,0,565,570,3,76,38,0,566,567,
  	5,46,0,0,567,569,3,76,38,0,568,566,1,0,0,0,569,572,1,0,0,0,570,568,1,
  	0,0,0,570,571,1,0,0,0,571,75,1,0,0,0,572,570,1,0,0,0,573,576,3,106,53,
  	0,574,575,5,10,0,0,575,577,3,106,53,0,576,574,1,0,0,0,576,577,1,0,0,0,
  	577,77,1,0,0,0,578,584,3,90,45,0,579,580,5,13,0,0,580,581,3,90,45,0,581,
  	582,5,15,0,0,582,583,3,78,39,0,583,585,1,0,0,0,584,579,1,0,0,0,584,585,
  	1,0,0,0,585,593,1,0,0,0,586,588,5,24,0,0,587,589,3,80,40,0,588,587,1,
  	0,0,0,588,589,1,0,0,0,589,590,1,0,0,0,590,591,5,47,0,0,591,593,3,78,39,
  	0,592,578,1,0,0,0,592,586,1,0,0,0,593,79,1,0,0,0,594,595,3,82,41,0,595,
  	596,5,46,0,0,596,598,1,0,0,0,597,594,1,0,0,0,597,598,1,0,0,0,598,609,
  	1,0,0,0,599,602,3,86,43,0,600,601,5,46,0,0,601,603,3,82,41,0,602,600,
  	1,0,0,0,602,603,1,0,0,0,603,606,1,0,0,0,604,605,5,46,0,0,605,607,3,88,
  	44,0,606,604,1,0,0,0,606,607,1,0,0,0,607,610,1,0,0,0,608,610,3,88,44,
  	0,609,599,1,0,0,0,609,608,1,0,0,0,610,612,1,0,0,0,611,613,5,46,0,0,612,
  	611,1,0,0,0,612,613,1,0,0,0,613,619,1,0,0,0,614,616,3,82,41,0,615,617,
  	5,46,0,0,616,615,1,0,0,0,616,617,1,0,0,0,617,619,1,0,0,0,618,597,1,0,
  	0,0,618,614,1,0,0,0,619,81,1,0,0,0,620,625,3,84,42,0,621,622,5,46,0,0,
  	622,624,3,84,42,0,623,621,1,0,0,0,624,627,1,0,0,0,625,623,1,0,0,0,625,
  	626,1,0,0,0,626,83,1,0,0,0,627,625,1,0,0,0,628,631,3,106,53,0,629,630,
  	5,50,0,0,630,632,3,78,39,0,631,629,1,0,0,0,631,632,1,0,0,0,632,635,1,
  	0,0,0,633,635,5,45,0,0,634,628,1,0,0,0,634,633,1,0,0,0,635,85,1,0,0,0,
  	636,637,5,45,0,0,637,638,3,106,53,0,638,87,1,0,0,0,639,640,5,49,0,0,640,
  	641,3,106,53,0,641,89,1,0,0,0,642,643,6,45,-1,0,643,647,3,92,46,0,644,
  	645,5,27,0,0,645,647,3,90,45,3,646,642,1,0,0,0,646,644,1,0,0,0,647,656,
  	1,0,0,0,648,649,10,2,0,0,649,650,5,26,0,0,650,655,3,90,45,3,651,652,10,
  	1,0,0,652,653,5,25,0,0,653,655,3,90,45,2,654,648,1,0,0,0,654,651,1,0,
  	0,0,655,658,1,0,0,0,656,654,1,0,0,0,656,657,1,0,0,0,657,91,1,0,0,0,658,
  	656,1,0,0,0,659,660,6,46,-1,0,660,661,3,94,47,0,661,683,1,0,0,0,662,678,
  	10,2,0,0,663,679,5,62,0,0,664,679,5,63,0,0,665,679,5,64,0,0,666,679,5,
  	65,0,0,667,679,5,66,0,0,668,679,5,67,0,0,669,679,5,68,0,0,670,672,5,27,
  	0,0,671,670,1,0,0,0,671,672,1,0,0,0,672,673,1,0,0,0,673,679,5,18,0,0,
  	674,676,5,28,0,0,675,677,5,27,0,0,676,675,1,0,0,0,676,677,1,0,0,0,677,
  	679,1,0,0,0,678,663,1,0,0,0,678,664,1,0,0,0,678,665,1,0,0,0,678,666,1,
  	0,0,0,678,667,1,0,0,0,678,668,1,0,0,0,678,669,1,0,0,0,678,671,1,0,0,0,
  	678,674,1,0,0,0,679,680,1,0,0,0,680,682,3,92,46,3,681,662,1,0,0,0,682,
  	685,1,0,0,0,683,681,1,0,0,0,683,684,1,0,0,0,684,93,1,0,0,0,685,683,1,
  	0,0,0,686,688,6,47,-1,0,687,689,5,36,0,0,688,687,1,0,0,0,688,689,1,0,
  	0,0,689,690,1,0,0,0,690,694,3,96,48,0,691,693,3,118,59,0,692,691,1,0,
  	0,0,693,696,1,0,0,0,694,692,1,0,0,0,694,695,1,0,0,0,695,700,1,0,0,0,696,
  	694,1,0,0,0,697,698,7,4,0,0,698,700,3,94,47,2,699,686,1,0,0,0,699,697,
  	1,0,0,0,700,706,1,0,0,0,701,702,10,1,0,0,702,703,7,5,0,0,703,705,3,94,
  	47,2,704,701,1,0,0,0,705,708,1,0,0,0,706,704,1,0,0,0,706,707,1,0,0,0,
  	707,95,1,0,0,0,708,706,1,0,0,0,709,712,5,86,0,0,710,713,3,114,57,0,711,
  	713,3,102,51,0,712,710,1,0,0,0,712,711,1,0,0,0,712,713,1,0,0,0,713,714,
  	1,0,0,0,714,748,5,87,0,0,715,717,5,90,0,0,716,718,3,102,51,0,717,716,
  	1,0,0,0,717,718,1,0,0,0,718,719,1,0,0,0,719,748,5,91,0,0,720,722,5,88,
  	0,0,721,723,3,98,49,0,722,721,1,0,0,0,722,723,1,0,0,0,723,724,1,0,0,0,
  	724,748,5,89,0,0,725,726,5,88,0,0,726,727,3,100,50,0,727,728,5,89,0,0,
  	728,748,1,0,0,0,729,730,5,44,0,0,730,732,3,102,51,0,731,733,5,46,0,0,
  	732,731,1,0,0,0,732,733,1,0,0,0,733,734,1,0,0,0,734,735,5,44,0,0,735,
  	748,1,0,0,0,736,748,3,106,53,0,737,739,5,57,0,0,738,737,1,0,0,0,738,739,
  	1,0,0,0,739,740,1,0,0,0,740,748,3,110,55,0,741,748,5,20,0,0,742,744,5,
  	79,0,0,743,742,1,0,0,0,744,745,1,0,0,0,745,743,1,0,0,0,745,746,1,0,0,
  	0,746,748,1,0,0,0,747,709,1,0,0,0,747,715,1,0,0,0,747,720,1,0,0,0,747,
  	725,1,0,0,0,747,729,1,0,0,0,747,736,1,0,0,0,747,738,1,0,0,0,747,741,1,
  	0,0,0,747,743,1,0,0,0,748,97,1,0,0,0,749,750,3,78,39,0,750,751,5,47,0,
  	0,751,752,3,78,39,0,752,756,1,0,0,0,753,754,5,49,0,0,754,756,3,94,47,
  	0,755,749,1,0,0,0,755,753,1,0,0,0,756,768,1,0,0,0,757,764,5,46,0,0,758,
  	759,3,78,39,0,759,760,5,47,0,0,760,761,3,78,39,0,761,765,1,0,0,0,762,
  	763,5,49,0,0,763,765,3,94,47,0,764,758,1,0,0,0,764,762,1,0,0,0,765,767,
  	1,0,0,0,766,757,1,0,0,0,767,770,1,0,0,0,768,766,1,0,0,0,768,769,1,0,0,
  	0,769,772,1,0,0,0,770,768,1,0,0,0,771,773,5,46,0,0,772,771,1,0,0,0,772,
  	773,1,0,0,0,773,99,1,0,0,0,774,775,3,102,51,0,775,101,1,0,0,0,776,781,
  	3,78,39,0,777,778,5,46,0,0,778,780,3,78,39,0,779,777,1,0,0,0,780,783,
  	1,0,0,0,781,779,1,0,0,0,781,782,1,0,0,0,782,103,1,0,0,0,783,781,1,0,0,
  	0,784,785,6,52,-1,0,785,786,3,106,53,0,786,792,1,0,0,0,787,788,10,2,0,
  	0,788,789,5,43,0,0,789,791,3,106,53,0,790,787,1,0,0,0,791,794,1,0,0,0,
  	792,790,1,0,0,0,792,793,1,0,0,0,793,105,1,0,0,0,794,792,1,0,0,0,795,798,
  	5,92,0,0,796,798,3,108,54,0,797,795,1,0,0,0,797,796,1,0,0,0,798,107,1,
  	0,0,0,799,800,7,6,0,0,800,109,1,0,0,0,801,805,3,112,56,0,802,805,5,84,
  	0,0,803,805,5,85,0,0,804,801,1,0,0,0,804,802,1,0,0,0,804,803,1,0,0,0,
  	805,111,1,0,0,0,806,807,7,7,0,0,807,113,1,0,0,0,808,810,5,30,0,0,809,
  	811,3,116,58,0,810,809,1,0,0,0,810,811,1,0,0,0,811,115,1,0,0,0,812,813,
  	3,102,51,0,813,117,1,0,0,0,814,815,5,43,0,0,815,817,3,106,53,0,816,818,
  	3,120,60,0,817,816,1,0,0,0,817,818,1,0,0,0,818,821,1,0,0,0,819,821,3,
  	120,60,0,820,814,1,0,0,0,820,819,1,0,0,0,821,119,1,0,0,0,822,824,5,86,
  	0,0,823,825,3,122,61,0,824,823,1,0,0,0,824,825,1,0,0,0,825,826,1,0,0,
  	0,826,832,5,87,0,0,827,828,5,90,0,0,828,829,3,126,63,0,829,830,5,91,0,
  	0,830,832,1,0,0,0,831,822,1,0,0,0,831,827,1,0,0,0,832,121,1,0,0,0,833,
  	838,3,124,62,0,834,835,5,46,0,0,835,837,3,124,62,0,836,834,1,0,0,0,837,
  	840,1,0,0,0,838,836,1,0,0,0,838,839,1,0,0,0,839,842,1,0,0,0,840,838,1,
  	0,0,0,841,843,5,46,0,0,842,841,1,0,0,0,842,843,1,0,0,0,843,123,1,0,0,
  	0,844,847,3,78,39,0,845,846,5,50,0,0,846,848,3,78,39,0,847,845,1,0,0,
  	0,847,848,1,0,0,0,848,852,1,0,0,0,849,850,7,8,0,0,850,852,3,78,39,0,851,
  	844,1,0,0,0,851,849,1,0,0,0,852,125,1,0,0,0,853,858,3,128,64,0,854,855,
  	5,46,0,0,855,857,3,128,64,0,856,854,1,0,0,0,857,860,1,0,0,0,858,856,1,
  	0,0,0,858,859,1,0,0,0,859,862,1,0,0,0,860,858,1,0,0,0,861,863,5,46,0,
  	0,862,861,1,0,0,0,862,863,1,0,0,0,863,127,1,0,0,0,864,872,3,78,39,0,865,
  	867,5,47,0,0,866,868,3,78,39,0,867,866,1,0,0,0,867,868,1,0,0,0,868,870,
  	1,0,0,0,869,871,3,130,65,0,870,869,1,0,0,0,870,871,1,0,0,0,871,873,1,
  	0,0,0,872,865,1,0,0,0,872,873,1,0,0,0,873,882,1,0,0,0,874,876,5,47,0,
  	0,875,877,3,78,39,0,876,875,1,0,0,0,876,877,1,0,0,0,877,879,1,0,0,0,878,
  	880,3,130,65,0,879,878,1,0,0,0,879,880,1,0,0,0,880,882,1,0,0,0,881,864,
  	1,0,0,0,881,874,1,0,0,0,882,129,1,0,0,0,883,885,5,47,0,0,884,886,3,78,
  	39,0,885,884,1,0,0,0,885,886,1,0,0,0,886,131,1,0,0,0,887,888,5,17,0,0,
  	888,889,3,68,34,0,889,890,5,18,0,0,890,892,3,90,45,0,891,893,3,134,67,
  	0,892,891,1,0,0,0,892,893,1,0,0,0,893,133,1,0,0,0,894,901,3,132,66,0,
  	895,896,5,13,0,0,896,898,3,78,39,0,897,899,3,134,67,0,898,897,1,0,0,0,
  	898,899,1,0,0,0,899,901,1,0,0,0,900,894,1,0,0,0,900,895,1,0,0,0,901,135,
  	1,0,0,0,132,139,148,152,154,160,165,174,178,185,188,197,205,208,211,214,
  	217,225,234,241,245,253,257,263,266,286,292,294,303,306,312,318,327,332,
  	336,339,342,346,348,361,367,370,375,382,386,392,397,408,412,426,434,438,
  	458,467,472,479,485,492,494,501,509,511,522,525,528,536,543,547,554,558,
  	563,570,576,584,588,592,597,602,606,609,612,616,618,625,631,634,646,654,
  	656,671,676,678,683,688,694,699,706,712,717,722,732,738,745,747,755,764,
  	768,772,781,792,797,804,810,817,820,824,831,838,842,847,851,858,862,867,
  	870,872,876,879,881,885,892,898,900
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  pscriptparserParserStaticData = staticData.release();
}

}

pscriptParser::pscriptParser(TokenStream *input) : pscriptParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

pscriptParser::pscriptParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : pscriptParserBase(input) {
  pscriptParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *pscriptparserParserStaticData->atn, pscriptparserParserStaticData->decisionToDFA, pscriptparserParserStaticData->sharedContextCache, options);
}

pscriptParser::~pscriptParser() {
  delete _interpreter;
}

const atn::ATN& pscriptParser::getATN() const {
  return *pscriptparserParserStaticData->atn;
}

std::string pscriptParser::getGrammarFileName() const {
  return "pscriptParser.g4";
}

const std::vector<std::string>& pscriptParser::getRuleNames() const {
  return pscriptparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& pscriptParser::getVocabulary() const {
  return pscriptparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView pscriptParser::getSerializedATN() const {
  return pscriptparserParserStaticData->serializedATN;
}


//----------------- RootContext ------------------------------------------------------------------

pscriptParser::RootContext::RootContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::RootContext::EOF() {
  return getToken(pscriptParser::EOF, 0);
}

pscriptParser::Single_inputContext* pscriptParser::RootContext::single_input() {
  return getRuleContext<pscriptParser::Single_inputContext>(0);
}

pscriptParser::File_inputContext* pscriptParser::RootContext::file_input() {
  return getRuleContext<pscriptParser::File_inputContext>(0);
}

pscriptParser::Eval_inputContext* pscriptParser::RootContext::eval_input() {
  return getRuleContext<pscriptParser::Eval_inputContext>(0);
}


size_t pscriptParser::RootContext::getRuleIndex() const {
  return pscriptParser::RuleRoot;
}

void pscriptParser::RootContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoot(this);
}

void pscriptParser::RootContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoot(this);
}


std::any pscriptParser::RootContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitRoot(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::RootContext* pscriptParser::root() {
  RootContext *_localctx = _tracker.createInstance<RootContext>(_ctx, getState());
  enterRule(_localctx, 0, pscriptParser::RuleRoot);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(139);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      setState(136);
      single_input();
      break;
    }

    case 2: {
      setState(137);
      file_input();
      break;
    }

    case 3: {
      setState(138);
      eval_input();
      break;
    }

    default:
      break;
    }
    setState(141);
    match(pscriptParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Single_inputContext ------------------------------------------------------------------

pscriptParser::Single_inputContext::Single_inputContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Single_inputContext::LINE_BREAK() {
  return getToken(pscriptParser::LINE_BREAK, 0);
}

pscriptParser::Simple_stmtContext* pscriptParser::Single_inputContext::simple_stmt() {
  return getRuleContext<pscriptParser::Simple_stmtContext>(0);
}

pscriptParser::Compound_stmtContext* pscriptParser::Single_inputContext::compound_stmt() {
  return getRuleContext<pscriptParser::Compound_stmtContext>(0);
}


size_t pscriptParser::Single_inputContext::getRuleIndex() const {
  return pscriptParser::RuleSingle_input;
}

void pscriptParser::Single_inputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingle_input(this);
}

void pscriptParser::Single_inputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingle_input(this);
}


std::any pscriptParser::Single_inputContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitSingle_input(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Single_inputContext* pscriptParser::single_input() {
  Single_inputContext *_localctx = _tracker.createInstance<Single_inputContext>(_ctx, getState());
  enterRule(_localctx, 2, pscriptParser::RuleSingle_input);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(148);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::LINE_BREAK: {
        enterOuterAlt(_localctx, 1);
        setState(143);
        match(pscriptParser::LINE_BREAK);
        break;
      }

      case pscriptParser::RETURN:
      case pscriptParser::RAISE:
      case pscriptParser::FROM:
      case pscriptParser::IMPORT:
      case pscriptParser::NONLOCAL:
      case pscriptParser::GLOBAL:
      case pscriptParser::ASSERT:
      case pscriptParser::NONE:
      case pscriptParser::YIELD:
      case pscriptParser::DEL:
      case pscriptParser::PASS:
      case pscriptParser::CONTINUE:
      case pscriptParser::BREAK:
      case pscriptParser::AWAIT:
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::VAR:
      case pscriptParser::CONST:
      case pscriptParser::LET:
      case pscriptParser::REVERSE_QUOTE:
      case pscriptParser::MINUS:
      case pscriptParser::STRING:
      case pscriptParser::DECIMAL_INTEGER:
      case pscriptParser::OCT_INTEGER:
      case pscriptParser::HEX_INTEGER:
      case pscriptParser::BIN_INTEGER:
      case pscriptParser::IMAG_NUMBER:
      case pscriptParser::FLOAT_NUMBER:
      case pscriptParser::OPEN_PAREN:
      case pscriptParser::OPEN_BRACE:
      case pscriptParser::OPEN_BRACKET:
      case pscriptParser::NAME: {
        enterOuterAlt(_localctx, 2);
        setState(144);
        simple_stmt();
        break;
      }

      case pscriptParser::DEF:
      case pscriptParser::IF:
      case pscriptParser::WHILE:
      case pscriptParser::FOR:
      case pscriptParser::TRY:
      case pscriptParser::WITH:
      case pscriptParser::CLASS:
      case pscriptParser::ASYNC:
      case pscriptParser::AT: {
        enterOuterAlt(_localctx, 3);
        setState(145);
        compound_stmt();
        setState(146);
        match(pscriptParser::LINE_BREAK);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_inputContext ------------------------------------------------------------------

pscriptParser::File_inputContext::File_inputContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> pscriptParser::File_inputContext::LINE_BREAK() {
  return getTokens(pscriptParser::LINE_BREAK);
}

tree::TerminalNode* pscriptParser::File_inputContext::LINE_BREAK(size_t i) {
  return getToken(pscriptParser::LINE_BREAK, i);
}

std::vector<pscriptParser::StmtContext *> pscriptParser::File_inputContext::stmt() {
  return getRuleContexts<pscriptParser::StmtContext>();
}

pscriptParser::StmtContext* pscriptParser::File_inputContext::stmt(size_t i) {
  return getRuleContext<pscriptParser::StmtContext>(i);
}


size_t pscriptParser::File_inputContext::getRuleIndex() const {
  return pscriptParser::RuleFile_input;
}

void pscriptParser::File_inputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_input(this);
}

void pscriptParser::File_inputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_input(this);
}


std::any pscriptParser::File_inputContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitFile_input(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::File_inputContext* pscriptParser::file_input() {
  File_inputContext *_localctx = _tracker.createInstance<File_inputContext>(_ctx, getState());
  enterRule(_localctx, 4, pscriptParser::RuleFile_input);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(152); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(152);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case pscriptParser::LINE_BREAK: {
          setState(150);
          match(pscriptParser::LINE_BREAK);
          break;
        }

        case pscriptParser::DEF:
        case pscriptParser::RETURN:
        case pscriptParser::RAISE:
        case pscriptParser::FROM:
        case pscriptParser::IMPORT:
        case pscriptParser::NONLOCAL:
        case pscriptParser::GLOBAL:
        case pscriptParser::ASSERT:
        case pscriptParser::IF:
        case pscriptParser::WHILE:
        case pscriptParser::FOR:
        case pscriptParser::TRY:
        case pscriptParser::NONE:
        case pscriptParser::WITH:
        case pscriptParser::CLASS:
        case pscriptParser::YIELD:
        case pscriptParser::DEL:
        case pscriptParser::PASS:
        case pscriptParser::CONTINUE:
        case pscriptParser::BREAK:
        case pscriptParser::ASYNC:
        case pscriptParser::AWAIT:
        case pscriptParser::TRUE:
        case pscriptParser::FALSE:
        case pscriptParser::VAR:
        case pscriptParser::CONST:
        case pscriptParser::LET:
        case pscriptParser::REVERSE_QUOTE:
        case pscriptParser::MINUS:
        case pscriptParser::AT:
        case pscriptParser::STRING:
        case pscriptParser::DECIMAL_INTEGER:
        case pscriptParser::OCT_INTEGER:
        case pscriptParser::HEX_INTEGER:
        case pscriptParser::BIN_INTEGER:
        case pscriptParser::IMAG_NUMBER:
        case pscriptParser::FLOAT_NUMBER:
        case pscriptParser::OPEN_PAREN:
        case pscriptParser::OPEN_BRACE:
        case pscriptParser::OPEN_BRACKET:
        case pscriptParser::NAME: {
          setState(151);
          stmt();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(154); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 144141438385077240) != 0) || ((((_la - 69) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 69)) & 11271169) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Eval_inputContext ------------------------------------------------------------------

pscriptParser::Eval_inputContext::Eval_inputContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::TestlistContext* pscriptParser::Eval_inputContext::testlist() {
  return getRuleContext<pscriptParser::TestlistContext>(0);
}

std::vector<tree::TerminalNode *> pscriptParser::Eval_inputContext::LINE_BREAK() {
  return getTokens(pscriptParser::LINE_BREAK);
}

tree::TerminalNode* pscriptParser::Eval_inputContext::LINE_BREAK(size_t i) {
  return getToken(pscriptParser::LINE_BREAK, i);
}


size_t pscriptParser::Eval_inputContext::getRuleIndex() const {
  return pscriptParser::RuleEval_input;
}

void pscriptParser::Eval_inputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEval_input(this);
}

void pscriptParser::Eval_inputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEval_input(this);
}


std::any pscriptParser::Eval_inputContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitEval_input(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Eval_inputContext* pscriptParser::eval_input() {
  Eval_inputContext *_localctx = _tracker.createInstance<Eval_inputContext>(_ctx, getState());
  enterRule(_localctx, 6, pscriptParser::RuleEval_input);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(156);
    testlist();
    setState(160);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == pscriptParser::LINE_BREAK) {
      setState(157);
      match(pscriptParser::LINE_BREAK);
      setState(162);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtContext ------------------------------------------------------------------

pscriptParser::StmtContext::StmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::Simple_stmtContext* pscriptParser::StmtContext::simple_stmt() {
  return getRuleContext<pscriptParser::Simple_stmtContext>(0);
}

pscriptParser::Compound_stmtContext* pscriptParser::StmtContext::compound_stmt() {
  return getRuleContext<pscriptParser::Compound_stmtContext>(0);
}


size_t pscriptParser::StmtContext::getRuleIndex() const {
  return pscriptParser::RuleStmt;
}

void pscriptParser::StmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmt(this);
}

void pscriptParser::StmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmt(this);
}


std::any pscriptParser::StmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitStmt(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::StmtContext* pscriptParser::stmt() {
  StmtContext *_localctx = _tracker.createInstance<StmtContext>(_ctx, getState());
  enterRule(_localctx, 8, pscriptParser::RuleStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(165);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::RETURN:
      case pscriptParser::RAISE:
      case pscriptParser::FROM:
      case pscriptParser::IMPORT:
      case pscriptParser::NONLOCAL:
      case pscriptParser::GLOBAL:
      case pscriptParser::ASSERT:
      case pscriptParser::NONE:
      case pscriptParser::YIELD:
      case pscriptParser::DEL:
      case pscriptParser::PASS:
      case pscriptParser::CONTINUE:
      case pscriptParser::BREAK:
      case pscriptParser::AWAIT:
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::VAR:
      case pscriptParser::CONST:
      case pscriptParser::LET:
      case pscriptParser::REVERSE_QUOTE:
      case pscriptParser::MINUS:
      case pscriptParser::STRING:
      case pscriptParser::DECIMAL_INTEGER:
      case pscriptParser::OCT_INTEGER:
      case pscriptParser::HEX_INTEGER:
      case pscriptParser::BIN_INTEGER:
      case pscriptParser::IMAG_NUMBER:
      case pscriptParser::FLOAT_NUMBER:
      case pscriptParser::OPEN_PAREN:
      case pscriptParser::OPEN_BRACE:
      case pscriptParser::OPEN_BRACKET:
      case pscriptParser::NAME: {
        enterOuterAlt(_localctx, 1);
        setState(163);
        simple_stmt();
        break;
      }

      case pscriptParser::DEF:
      case pscriptParser::IF:
      case pscriptParser::WHILE:
      case pscriptParser::FOR:
      case pscriptParser::TRY:
      case pscriptParser::WITH:
      case pscriptParser::CLASS:
      case pscriptParser::ASYNC:
      case pscriptParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(164);
        compound_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_stmtContext ------------------------------------------------------------------

pscriptParser::Compound_stmtContext::Compound_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t pscriptParser::Compound_stmtContext::getRuleIndex() const {
  return pscriptParser::RuleCompound_stmt;
}

void pscriptParser::Compound_stmtContext::copyFrom(Compound_stmtContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- While_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::While_stmtContext::WHILE() {
  return getToken(pscriptParser::WHILE, 0);
}

pscriptParser::TestContext* pscriptParser::While_stmtContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}

tree::TerminalNode* pscriptParser::While_stmtContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::While_stmtContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}

pscriptParser::Else_clauseContext* pscriptParser::While_stmtContext::else_clause() {
  return getRuleContext<pscriptParser::Else_clauseContext>(0);
}

pscriptParser::While_stmtContext::While_stmtContext(Compound_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::While_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhile_stmt(this);
}
void pscriptParser::While_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhile_stmt(this);
}

std::any pscriptParser::While_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitWhile_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Func_def_stmtContext ------------------------------------------------------------------

pscriptParser::FuncdefContext* pscriptParser::Func_def_stmtContext::funcdef() {
  return getRuleContext<pscriptParser::FuncdefContext>(0);
}

std::vector<pscriptParser::DecoratorContext *> pscriptParser::Func_def_stmtContext::decorator() {
  return getRuleContexts<pscriptParser::DecoratorContext>();
}

pscriptParser::DecoratorContext* pscriptParser::Func_def_stmtContext::decorator(size_t i) {
  return getRuleContext<pscriptParser::DecoratorContext>(i);
}

pscriptParser::Func_def_stmtContext::Func_def_stmtContext(Compound_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Func_def_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_def_stmt(this);
}
void pscriptParser::Func_def_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_def_stmt(this);
}

std::any pscriptParser::Func_def_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitFunc_def_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Try_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Try_stmtContext::TRY() {
  return getToken(pscriptParser::TRY, 0);
}

tree::TerminalNode* pscriptParser::Try_stmtContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::Try_stmtContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}

pscriptParser::Finally_clauseContext* pscriptParser::Try_stmtContext::finally_clause() {
  return getRuleContext<pscriptParser::Finally_clauseContext>(0);
}

std::vector<pscriptParser::Except_clauseContext *> pscriptParser::Try_stmtContext::except_clause() {
  return getRuleContexts<pscriptParser::Except_clauseContext>();
}

pscriptParser::Except_clauseContext* pscriptParser::Try_stmtContext::except_clause(size_t i) {
  return getRuleContext<pscriptParser::Except_clauseContext>(i);
}

pscriptParser::Else_clauseContext* pscriptParser::Try_stmtContext::else_clause() {
  return getRuleContext<pscriptParser::Else_clauseContext>(0);
}

pscriptParser::Try_stmtContext::Try_stmtContext(Compound_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Try_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTry_stmt(this);
}
void pscriptParser::Try_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTry_stmt(this);
}

std::any pscriptParser::Try_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitTry_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- If_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::If_stmtContext::IF() {
  return getToken(pscriptParser::IF, 0);
}

tree::TerminalNode* pscriptParser::If_stmtContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::If_stmtContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}

pscriptParser::TestContext* pscriptParser::If_stmtContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}

std::vector<pscriptParser::Elif_clauseContext *> pscriptParser::If_stmtContext::elif_clause() {
  return getRuleContexts<pscriptParser::Elif_clauseContext>();
}

pscriptParser::Elif_clauseContext* pscriptParser::If_stmtContext::elif_clause(size_t i) {
  return getRuleContext<pscriptParser::Elif_clauseContext>(i);
}

pscriptParser::Else_clauseContext* pscriptParser::If_stmtContext::else_clause() {
  return getRuleContext<pscriptParser::Else_clauseContext>(0);
}

pscriptParser::If_stmtContext::If_stmtContext(Compound_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::If_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_stmt(this);
}
void pscriptParser::If_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_stmt(this);
}

std::any pscriptParser::If_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitIf_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- With_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::With_stmtContext::WITH() {
  return getToken(pscriptParser::WITH, 0);
}

std::vector<pscriptParser::With_itemContext *> pscriptParser::With_stmtContext::with_item() {
  return getRuleContexts<pscriptParser::With_itemContext>();
}

pscriptParser::With_itemContext* pscriptParser::With_stmtContext::with_item(size_t i) {
  return getRuleContext<pscriptParser::With_itemContext>(i);
}

tree::TerminalNode* pscriptParser::With_stmtContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::With_stmtContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}

tree::TerminalNode* pscriptParser::With_stmtContext::ASYNC() {
  return getToken(pscriptParser::ASYNC, 0);
}

std::vector<tree::TerminalNode *> pscriptParser::With_stmtContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::With_stmtContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}

pscriptParser::With_stmtContext::With_stmtContext(Compound_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::With_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_stmt(this);
}
void pscriptParser::With_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_stmt(this);
}

std::any pscriptParser::With_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitWith_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- For_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::For_stmtContext::FOR() {
  return getToken(pscriptParser::FOR, 0);
}

pscriptParser::ExprlistContext* pscriptParser::For_stmtContext::exprlist() {
  return getRuleContext<pscriptParser::ExprlistContext>(0);
}

tree::TerminalNode* pscriptParser::For_stmtContext::IN() {
  return getToken(pscriptParser::IN, 0);
}

pscriptParser::TestlistContext* pscriptParser::For_stmtContext::testlist() {
  return getRuleContext<pscriptParser::TestlistContext>(0);
}

tree::TerminalNode* pscriptParser::For_stmtContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::For_stmtContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}

tree::TerminalNode* pscriptParser::For_stmtContext::ASYNC() {
  return getToken(pscriptParser::ASYNC, 0);
}

pscriptParser::Else_clauseContext* pscriptParser::For_stmtContext::else_clause() {
  return getRuleContext<pscriptParser::Else_clauseContext>(0);
}

pscriptParser::For_stmtContext::For_stmtContext(Compound_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::For_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_stmt(this);
}
void pscriptParser::For_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_stmt(this);
}

std::any pscriptParser::For_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitFor_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Class_def_stmtContext ------------------------------------------------------------------

pscriptParser::ClassdefContext* pscriptParser::Class_def_stmtContext::classdef() {
  return getRuleContext<pscriptParser::ClassdefContext>(0);
}

std::vector<pscriptParser::DecoratorContext *> pscriptParser::Class_def_stmtContext::decorator() {
  return getRuleContexts<pscriptParser::DecoratorContext>();
}

pscriptParser::DecoratorContext* pscriptParser::Class_def_stmtContext::decorator(size_t i) {
  return getRuleContext<pscriptParser::DecoratorContext>(i);
}

pscriptParser::Class_def_stmtContext::Class_def_stmtContext(Compound_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Class_def_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_def_stmt(this);
}
void pscriptParser::Class_def_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_def_stmt(this);
}

std::any pscriptParser::Class_def_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitClass_def_stmt(this);
  else
    return visitor->visitChildren(this);
}
pscriptParser::Compound_stmtContext* pscriptParser::compound_stmt() {
  Compound_stmtContext *_localctx = _tracker.createInstance<Compound_stmtContext>(_ctx, getState());
  enterRule(_localctx, 10, pscriptParser::RuleCompound_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(245);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<pscriptParser::If_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(167);
      match(pscriptParser::IF);
      setState(168);
      antlrcpp::downCast<If_stmtContext *>(_localctx)->cond = test();
      setState(169);
      match(pscriptParser::COLON);
      setState(170);
      suite();
      setState(174);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == pscriptParser::ELIF) {
        setState(171);
        elif_clause();
        setState(176);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(178);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::ELSE) {
        setState(177);
        else_clause();
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<pscriptParser::While_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(180);
      match(pscriptParser::WHILE);
      setState(181);
      test();
      setState(182);
      match(pscriptParser::COLON);
      setState(183);
      suite();
      setState(185);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::ELSE) {
        setState(184);
        else_clause();
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<pscriptParser::For_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(188);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::ASYNC) {
        setState(187);
        match(pscriptParser::ASYNC);
      }
      setState(190);
      match(pscriptParser::FOR);
      setState(191);
      exprlist();
      setState(192);
      match(pscriptParser::IN);
      setState(193);
      testlist();
      setState(194);
      match(pscriptParser::COLON);
      setState(195);
      suite();
      setState(197);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::ELSE) {
        setState(196);
        else_clause();
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<pscriptParser::Try_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(199);
      match(pscriptParser::TRY);
      setState(200);
      match(pscriptParser::COLON);
      setState(201);
      suite();
      setState(214);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case pscriptParser::EXCEPT: {
          setState(203); 
          _errHandler->sync(this);
          _la = _input->LA(1);
          do {
            setState(202);
            except_clause();
            setState(205); 
            _errHandler->sync(this);
            _la = _input->LA(1);
          } while (_la == pscriptParser::EXCEPT);
          setState(208);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == pscriptParser::ELSE) {
            setState(207);
            else_clause();
          }
          setState(211);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == pscriptParser::FINALLY) {
            setState(210);
            finally_clause();
          }
          break;
        }

        case pscriptParser::FINALLY: {
          setState(213);
          finally_clause();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<pscriptParser::With_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(217);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::ASYNC) {
        setState(216);
        match(pscriptParser::ASYNC);
      }
      setState(219);
      match(pscriptParser::WITH);
      setState(220);
      with_item();
      setState(225);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == pscriptParser::COMMA) {
        setState(221);
        match(pscriptParser::COMMA);
        setState(222);
        with_item();
        setState(227);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(228);
      match(pscriptParser::COLON);
      setState(229);
      suite();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<pscriptParser::Class_def_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(234);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == pscriptParser::AT) {
        setState(231);
        decorator();
        setState(236);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(237);
      classdef();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<pscriptParser::Func_def_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(241);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == pscriptParser::AT) {
        setState(238);
        decorator();
        setState(243);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(244);
      funcdef();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SuiteContext ------------------------------------------------------------------

pscriptParser::SuiteContext::SuiteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::Simple_stmtContext* pscriptParser::SuiteContext::simple_stmt() {
  return getRuleContext<pscriptParser::Simple_stmtContext>(0);
}

tree::TerminalNode* pscriptParser::SuiteContext::LINE_BREAK() {
  return getToken(pscriptParser::LINE_BREAK, 0);
}

tree::TerminalNode* pscriptParser::SuiteContext::INDENT() {
  return getToken(pscriptParser::INDENT, 0);
}

tree::TerminalNode* pscriptParser::SuiteContext::DEDENT() {
  return getToken(pscriptParser::DEDENT, 0);
}

std::vector<pscriptParser::StmtContext *> pscriptParser::SuiteContext::stmt() {
  return getRuleContexts<pscriptParser::StmtContext>();
}

pscriptParser::StmtContext* pscriptParser::SuiteContext::stmt(size_t i) {
  return getRuleContext<pscriptParser::StmtContext>(i);
}


size_t pscriptParser::SuiteContext::getRuleIndex() const {
  return pscriptParser::RuleSuite;
}

void pscriptParser::SuiteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSuite(this);
}

void pscriptParser::SuiteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSuite(this);
}


std::any pscriptParser::SuiteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitSuite(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::SuiteContext* pscriptParser::suite() {
  SuiteContext *_localctx = _tracker.createInstance<SuiteContext>(_ctx, getState());
  enterRule(_localctx, 12, pscriptParser::RuleSuite);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(257);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::RETURN:
      case pscriptParser::RAISE:
      case pscriptParser::FROM:
      case pscriptParser::IMPORT:
      case pscriptParser::NONLOCAL:
      case pscriptParser::GLOBAL:
      case pscriptParser::ASSERT:
      case pscriptParser::NONE:
      case pscriptParser::YIELD:
      case pscriptParser::DEL:
      case pscriptParser::PASS:
      case pscriptParser::CONTINUE:
      case pscriptParser::BREAK:
      case pscriptParser::AWAIT:
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::VAR:
      case pscriptParser::CONST:
      case pscriptParser::LET:
      case pscriptParser::REVERSE_QUOTE:
      case pscriptParser::MINUS:
      case pscriptParser::STRING:
      case pscriptParser::DECIMAL_INTEGER:
      case pscriptParser::OCT_INTEGER:
      case pscriptParser::HEX_INTEGER:
      case pscriptParser::BIN_INTEGER:
      case pscriptParser::IMAG_NUMBER:
      case pscriptParser::FLOAT_NUMBER:
      case pscriptParser::OPEN_PAREN:
      case pscriptParser::OPEN_BRACE:
      case pscriptParser::OPEN_BRACKET:
      case pscriptParser::NAME: {
        enterOuterAlt(_localctx, 1);
        setState(247);
        simple_stmt();
        break;
      }

      case pscriptParser::LINE_BREAK: {
        enterOuterAlt(_localctx, 2);
        setState(248);
        match(pscriptParser::LINE_BREAK);
        setState(249);
        match(pscriptParser::INDENT);
        setState(251); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(250);
          stmt();
          setState(253); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 144141438385077232) != 0) || ((((_la - 69) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 69)) & 11271169) != 0));
        setState(255);
        match(pscriptParser::DEDENT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorContext ------------------------------------------------------------------

pscriptParser::DecoratorContext::DecoratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::DecoratorContext::AT() {
  return getToken(pscriptParser::AT, 0);
}

pscriptParser::Dotted_nameContext* pscriptParser::DecoratorContext::dotted_name() {
  return getRuleContext<pscriptParser::Dotted_nameContext>(0);
}

tree::TerminalNode* pscriptParser::DecoratorContext::LINE_BREAK() {
  return getToken(pscriptParser::LINE_BREAK, 0);
}

tree::TerminalNode* pscriptParser::DecoratorContext::OPEN_PAREN() {
  return getToken(pscriptParser::OPEN_PAREN, 0);
}

tree::TerminalNode* pscriptParser::DecoratorContext::CLOSE_PAREN() {
  return getToken(pscriptParser::CLOSE_PAREN, 0);
}

pscriptParser::ArglistContext* pscriptParser::DecoratorContext::arglist() {
  return getRuleContext<pscriptParser::ArglistContext>(0);
}


size_t pscriptParser::DecoratorContext::getRuleIndex() const {
  return pscriptParser::RuleDecorator;
}

void pscriptParser::DecoratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecorator(this);
}

void pscriptParser::DecoratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecorator(this);
}


std::any pscriptParser::DecoratorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitDecorator(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::DecoratorContext* pscriptParser::decorator() {
  DecoratorContext *_localctx = _tracker.createInstance<DecoratorContext>(_ctx, getState());
  enterRule(_localctx, 14, pscriptParser::RuleDecorator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(259);
    match(pscriptParser::AT);
    setState(260);
    dotted_name(0);
    setState(266);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::OPEN_PAREN) {
      setState(261);
      match(pscriptParser::OPEN_PAREN);
      setState(263);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2522632411344273408) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & 11007) != 0)) {
        setState(262);
        arglist();
      }
      setState(265);
      match(pscriptParser::CLOSE_PAREN);
    }
    setState(268);
    match(pscriptParser::LINE_BREAK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Elif_clauseContext ------------------------------------------------------------------

pscriptParser::Elif_clauseContext::Elif_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Elif_clauseContext::ELIF() {
  return getToken(pscriptParser::ELIF, 0);
}

pscriptParser::TestContext* pscriptParser::Elif_clauseContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}

tree::TerminalNode* pscriptParser::Elif_clauseContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::Elif_clauseContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}


size_t pscriptParser::Elif_clauseContext::getRuleIndex() const {
  return pscriptParser::RuleElif_clause;
}

void pscriptParser::Elif_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElif_clause(this);
}

void pscriptParser::Elif_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElif_clause(this);
}


std::any pscriptParser::Elif_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitElif_clause(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Elif_clauseContext* pscriptParser::elif_clause() {
  Elif_clauseContext *_localctx = _tracker.createInstance<Elif_clauseContext>(_ctx, getState());
  enterRule(_localctx, 16, pscriptParser::RuleElif_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(270);
    match(pscriptParser::ELIF);
    setState(271);
    test();
    setState(272);
    match(pscriptParser::COLON);
    setState(273);
    suite();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Else_clauseContext ------------------------------------------------------------------

pscriptParser::Else_clauseContext::Else_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Else_clauseContext::ELSE() {
  return getToken(pscriptParser::ELSE, 0);
}

tree::TerminalNode* pscriptParser::Else_clauseContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::Else_clauseContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}


size_t pscriptParser::Else_clauseContext::getRuleIndex() const {
  return pscriptParser::RuleElse_clause;
}

void pscriptParser::Else_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElse_clause(this);
}

void pscriptParser::Else_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElse_clause(this);
}


std::any pscriptParser::Else_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitElse_clause(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Else_clauseContext* pscriptParser::else_clause() {
  Else_clauseContext *_localctx = _tracker.createInstance<Else_clauseContext>(_ctx, getState());
  enterRule(_localctx, 18, pscriptParser::RuleElse_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(275);
    match(pscriptParser::ELSE);
    setState(276);
    match(pscriptParser::COLON);
    setState(277);
    suite();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Finally_clauseContext ------------------------------------------------------------------

pscriptParser::Finally_clauseContext::Finally_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Finally_clauseContext::FINALLY() {
  return getToken(pscriptParser::FINALLY, 0);
}

tree::TerminalNode* pscriptParser::Finally_clauseContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::Finally_clauseContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}


size_t pscriptParser::Finally_clauseContext::getRuleIndex() const {
  return pscriptParser::RuleFinally_clause;
}

void pscriptParser::Finally_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFinally_clause(this);
}

void pscriptParser::Finally_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFinally_clause(this);
}


std::any pscriptParser::Finally_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitFinally_clause(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Finally_clauseContext* pscriptParser::finally_clause() {
  Finally_clauseContext *_localctx = _tracker.createInstance<Finally_clauseContext>(_ctx, getState());
  enterRule(_localctx, 20, pscriptParser::RuleFinally_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(279);
    match(pscriptParser::FINALLY);
    setState(280);
    match(pscriptParser::COLON);
    setState(281);
    suite();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_itemContext ------------------------------------------------------------------

pscriptParser::With_itemContext::With_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::TestContext* pscriptParser::With_itemContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}

tree::TerminalNode* pscriptParser::With_itemContext::AS() {
  return getToken(pscriptParser::AS, 0);
}

pscriptParser::ExprContext* pscriptParser::With_itemContext::expr() {
  return getRuleContext<pscriptParser::ExprContext>(0);
}


size_t pscriptParser::With_itemContext::getRuleIndex() const {
  return pscriptParser::RuleWith_item;
}

void pscriptParser::With_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_item(this);
}

void pscriptParser::With_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_item(this);
}


std::any pscriptParser::With_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitWith_item(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::With_itemContext* pscriptParser::with_item() {
  With_itemContext *_localctx = _tracker.createInstance<With_itemContext>(_ctx, getState());
  enterRule(_localctx, 22, pscriptParser::RuleWith_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(283);
    test();
    setState(286);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::AS) {
      setState(284);
      match(pscriptParser::AS);
      setState(285);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Except_clauseContext ------------------------------------------------------------------

pscriptParser::Except_clauseContext::Except_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Except_clauseContext::EXCEPT() {
  return getToken(pscriptParser::EXCEPT, 0);
}

tree::TerminalNode* pscriptParser::Except_clauseContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::Except_clauseContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}

pscriptParser::TestContext* pscriptParser::Except_clauseContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}

tree::TerminalNode* pscriptParser::Except_clauseContext::AS() {
  return getToken(pscriptParser::AS, 0);
}

pscriptParser::NameContext* pscriptParser::Except_clauseContext::name() {
  return getRuleContext<pscriptParser::NameContext>(0);
}


size_t pscriptParser::Except_clauseContext::getRuleIndex() const {
  return pscriptParser::RuleExcept_clause;
}

void pscriptParser::Except_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExcept_clause(this);
}

void pscriptParser::Except_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExcept_clause(this);
}


std::any pscriptParser::Except_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitExcept_clause(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Except_clauseContext* pscriptParser::except_clause() {
  Except_clauseContext *_localctx = _tracker.createInstance<Except_clauseContext>(_ctx, getState());
  enterRule(_localctx, 24, pscriptParser::RuleExcept_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(288);
    match(pscriptParser::EXCEPT);
    setState(294);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2522034277018763264) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & 11007) != 0)) {
      setState(289);
      test();
      setState(292);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::AS) {
        setState(290);
        match(pscriptParser::AS);
        setState(291);
        name();
      }
    }
    setState(296);
    match(pscriptParser::COLON);
    setState(297);
    suite();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassdefContext ------------------------------------------------------------------

pscriptParser::ClassdefContext::ClassdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::ClassdefContext::CLASS() {
  return getToken(pscriptParser::CLASS, 0);
}

pscriptParser::NameContext* pscriptParser::ClassdefContext::name() {
  return getRuleContext<pscriptParser::NameContext>(0);
}

tree::TerminalNode* pscriptParser::ClassdefContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::ClassdefContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}

tree::TerminalNode* pscriptParser::ClassdefContext::OPEN_PAREN() {
  return getToken(pscriptParser::OPEN_PAREN, 0);
}

tree::TerminalNode* pscriptParser::ClassdefContext::CLOSE_PAREN() {
  return getToken(pscriptParser::CLOSE_PAREN, 0);
}

pscriptParser::ArglistContext* pscriptParser::ClassdefContext::arglist() {
  return getRuleContext<pscriptParser::ArglistContext>(0);
}


size_t pscriptParser::ClassdefContext::getRuleIndex() const {
  return pscriptParser::RuleClassdef;
}

void pscriptParser::ClassdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassdef(this);
}

void pscriptParser::ClassdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassdef(this);
}


std::any pscriptParser::ClassdefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitClassdef(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::ClassdefContext* pscriptParser::classdef() {
  ClassdefContext *_localctx = _tracker.createInstance<ClassdefContext>(_ctx, getState());
  enterRule(_localctx, 26, pscriptParser::RuleClassdef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(299);
    match(pscriptParser::CLASS);
    setState(300);
    name();
    setState(306);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::OPEN_PAREN) {
      setState(301);
      match(pscriptParser::OPEN_PAREN);
      setState(303);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2522632411344273408) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & 11007) != 0)) {
        setState(302);
        arglist();
      }
      setState(305);
      match(pscriptParser::CLOSE_PAREN);
    }
    setState(308);
    match(pscriptParser::COLON);
    setState(309);
    suite();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FuncdefContext ------------------------------------------------------------------

pscriptParser::FuncdefContext::FuncdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::FuncdefContext::DEF() {
  return getToken(pscriptParser::DEF, 0);
}

pscriptParser::NameContext* pscriptParser::FuncdefContext::name() {
  return getRuleContext<pscriptParser::NameContext>(0);
}

tree::TerminalNode* pscriptParser::FuncdefContext::OPEN_PAREN() {
  return getToken(pscriptParser::OPEN_PAREN, 0);
}

tree::TerminalNode* pscriptParser::FuncdefContext::CLOSE_PAREN() {
  return getToken(pscriptParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* pscriptParser::FuncdefContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SuiteContext* pscriptParser::FuncdefContext::suite() {
  return getRuleContext<pscriptParser::SuiteContext>(0);
}

tree::TerminalNode* pscriptParser::FuncdefContext::ASYNC() {
  return getToken(pscriptParser::ASYNC, 0);
}

pscriptParser::TypedargslistContext* pscriptParser::FuncdefContext::typedargslist() {
  return getRuleContext<pscriptParser::TypedargslistContext>(0);
}


size_t pscriptParser::FuncdefContext::getRuleIndex() const {
  return pscriptParser::RuleFuncdef;
}

void pscriptParser::FuncdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFuncdef(this);
}

void pscriptParser::FuncdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFuncdef(this);
}


std::any pscriptParser::FuncdefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitFuncdef(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::FuncdefContext* pscriptParser::funcdef() {
  FuncdefContext *_localctx = _tracker.createInstance<FuncdefContext>(_ctx, getState());
  enterRule(_localctx, 28, pscriptParser::RuleFuncdef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(312);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::ASYNC) {
      setState(311);
      match(pscriptParser::ASYNC);
    }
    setState(314);
    match(pscriptParser::DEF);
    setState(315);
    name();
    setState(316);
    match(pscriptParser::OPEN_PAREN);
    setState(318);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 38) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 38)) & 18014398509484163) != 0)) {
      setState(317);
      typedargslist();
    }
    setState(320);
    match(pscriptParser::CLOSE_PAREN);
    setState(321);
    match(pscriptParser::COLON);
    setState(322);
    suite();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedargslistContext ------------------------------------------------------------------

pscriptParser::TypedargslistContext::TypedargslistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::ArgsContext* pscriptParser::TypedargslistContext::args() {
  return getRuleContext<pscriptParser::ArgsContext>(0);
}

pscriptParser::KwargsContext* pscriptParser::TypedargslistContext::kwargs() {
  return getRuleContext<pscriptParser::KwargsContext>(0);
}

std::vector<pscriptParser::Def_parametersContext *> pscriptParser::TypedargslistContext::def_parameters() {
  return getRuleContexts<pscriptParser::Def_parametersContext>();
}

pscriptParser::Def_parametersContext* pscriptParser::TypedargslistContext::def_parameters(size_t i) {
  return getRuleContext<pscriptParser::Def_parametersContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::TypedargslistContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::TypedargslistContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::TypedargslistContext::getRuleIndex() const {
  return pscriptParser::RuleTypedargslist;
}

void pscriptParser::TypedargslistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedargslist(this);
}

void pscriptParser::TypedargslistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedargslist(this);
}


std::any pscriptParser::TypedargslistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitTypedargslist(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::TypedargslistContext* pscriptParser::typedargslist() {
  TypedargslistContext *_localctx = _tracker.createInstance<TypedargslistContext>(_ctx, getState());
  enterRule(_localctx, 30, pscriptParser::RuleTypedargslist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(348);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(327);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
      case 1: {
        setState(324);
        def_parameters();
        setState(325);
        match(pscriptParser::COMMA);
        break;
      }

      default:
        break;
      }
      setState(339);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case pscriptParser::STAR: {
          setState(329);
          args();
          setState(332);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
          case 1: {
            setState(330);
            match(pscriptParser::COMMA);
            setState(331);
            def_parameters();
            break;
          }

          default:
            break;
          }
          setState(336);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
          case 1: {
            setState(334);
            match(pscriptParser::COMMA);
            setState(335);
            kwargs();
            break;
          }

          default:
            break;
          }
          break;
        }

        case pscriptParser::POWER: {
          setState(338);
          kwargs();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(342);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::COMMA) {
        setState(341);
        match(pscriptParser::COMMA);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(344);
      def_parameters();
      setState(346);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::COMMA) {
        setState(345);
        match(pscriptParser::COMMA);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgsContext ------------------------------------------------------------------

pscriptParser::ArgsContext::ArgsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::ArgsContext::STAR() {
  return getToken(pscriptParser::STAR, 0);
}

pscriptParser::Named_parameterContext* pscriptParser::ArgsContext::named_parameter() {
  return getRuleContext<pscriptParser::Named_parameterContext>(0);
}


size_t pscriptParser::ArgsContext::getRuleIndex() const {
  return pscriptParser::RuleArgs;
}

void pscriptParser::ArgsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgs(this);
}

void pscriptParser::ArgsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgs(this);
}


std::any pscriptParser::ArgsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitArgs(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::ArgsContext* pscriptParser::args() {
  ArgsContext *_localctx = _tracker.createInstance<ArgsContext>(_ctx, getState());
  enterRule(_localctx, 32, pscriptParser::RuleArgs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(350);
    match(pscriptParser::STAR);
    setState(351);
    named_parameter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KwargsContext ------------------------------------------------------------------

pscriptParser::KwargsContext::KwargsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::KwargsContext::POWER() {
  return getToken(pscriptParser::POWER, 0);
}

pscriptParser::Named_parameterContext* pscriptParser::KwargsContext::named_parameter() {
  return getRuleContext<pscriptParser::Named_parameterContext>(0);
}


size_t pscriptParser::KwargsContext::getRuleIndex() const {
  return pscriptParser::RuleKwargs;
}

void pscriptParser::KwargsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKwargs(this);
}

void pscriptParser::KwargsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKwargs(this);
}


std::any pscriptParser::KwargsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitKwargs(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::KwargsContext* pscriptParser::kwargs() {
  KwargsContext *_localctx = _tracker.createInstance<KwargsContext>(_ctx, getState());
  enterRule(_localctx, 34, pscriptParser::RuleKwargs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(353);
    match(pscriptParser::POWER);
    setState(354);
    named_parameter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Def_parametersContext ------------------------------------------------------------------

pscriptParser::Def_parametersContext::Def_parametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::Def_parameterContext *> pscriptParser::Def_parametersContext::def_parameter() {
  return getRuleContexts<pscriptParser::Def_parameterContext>();
}

pscriptParser::Def_parameterContext* pscriptParser::Def_parametersContext::def_parameter(size_t i) {
  return getRuleContext<pscriptParser::Def_parameterContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::Def_parametersContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::Def_parametersContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::Def_parametersContext::getRuleIndex() const {
  return pscriptParser::RuleDef_parameters;
}

void pscriptParser::Def_parametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDef_parameters(this);
}

void pscriptParser::Def_parametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDef_parameters(this);
}


std::any pscriptParser::Def_parametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitDef_parameters(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Def_parametersContext* pscriptParser::def_parameters() {
  Def_parametersContext *_localctx = _tracker.createInstance<Def_parametersContext>(_ctx, getState());
  enterRule(_localctx, 36, pscriptParser::RuleDef_parameters);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(356);
    def_parameter();
    setState(361);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(357);
        match(pscriptParser::COMMA);
        setState(358);
        def_parameter(); 
      }
      setState(363);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Def_parameterContext ------------------------------------------------------------------

pscriptParser::Def_parameterContext::Def_parameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::Named_parameterContext* pscriptParser::Def_parameterContext::named_parameter() {
  return getRuleContext<pscriptParser::Named_parameterContext>(0);
}

tree::TerminalNode* pscriptParser::Def_parameterContext::ASSIGN() {
  return getToken(pscriptParser::ASSIGN, 0);
}

pscriptParser::TestContext* pscriptParser::Def_parameterContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}

tree::TerminalNode* pscriptParser::Def_parameterContext::STAR() {
  return getToken(pscriptParser::STAR, 0);
}


size_t pscriptParser::Def_parameterContext::getRuleIndex() const {
  return pscriptParser::RuleDef_parameter;
}

void pscriptParser::Def_parameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDef_parameter(this);
}

void pscriptParser::Def_parameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDef_parameter(this);
}


std::any pscriptParser::Def_parameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitDef_parameter(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Def_parameterContext* pscriptParser::def_parameter() {
  Def_parameterContext *_localctx = _tracker.createInstance<Def_parameterContext>(_ctx, getState());
  enterRule(_localctx, 38, pscriptParser::RuleDef_parameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(370);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::NAME: {
        enterOuterAlt(_localctx, 1);
        setState(364);
        named_parameter();
        setState(367);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == pscriptParser::ASSIGN) {
          setState(365);
          match(pscriptParser::ASSIGN);
          setState(366);
          test();
        }
        break;
      }

      case pscriptParser::STAR: {
        enterOuterAlt(_localctx, 2);
        setState(369);
        match(pscriptParser::STAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Named_parameterContext ------------------------------------------------------------------

pscriptParser::Named_parameterContext::Named_parameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::NameContext* pscriptParser::Named_parameterContext::name() {
  return getRuleContext<pscriptParser::NameContext>(0);
}

tree::TerminalNode* pscriptParser::Named_parameterContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::TestContext* pscriptParser::Named_parameterContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}


size_t pscriptParser::Named_parameterContext::getRuleIndex() const {
  return pscriptParser::RuleNamed_parameter;
}

void pscriptParser::Named_parameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamed_parameter(this);
}

void pscriptParser::Named_parameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamed_parameter(this);
}


std::any pscriptParser::Named_parameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitNamed_parameter(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Named_parameterContext* pscriptParser::named_parameter() {
  Named_parameterContext *_localctx = _tracker.createInstance<Named_parameterContext>(_ctx, getState());
  enterRule(_localctx, 40, pscriptParser::RuleNamed_parameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(372);
    name();
    setState(375);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::COLON) {
      setState(373);
      match(pscriptParser::COLON);
      setState(374);
      test();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_stmtContext ------------------------------------------------------------------

pscriptParser::Simple_stmtContext::Simple_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::Small_stmtContext *> pscriptParser::Simple_stmtContext::small_stmt() {
  return getRuleContexts<pscriptParser::Small_stmtContext>();
}

pscriptParser::Small_stmtContext* pscriptParser::Simple_stmtContext::small_stmt(size_t i) {
  return getRuleContext<pscriptParser::Small_stmtContext>(i);
}

tree::TerminalNode* pscriptParser::Simple_stmtContext::LINE_BREAK() {
  return getToken(pscriptParser::LINE_BREAK, 0);
}

tree::TerminalNode* pscriptParser::Simple_stmtContext::EOF() {
  return getToken(pscriptParser::EOF, 0);
}

std::vector<tree::TerminalNode *> pscriptParser::Simple_stmtContext::SEMI_COLON() {
  return getTokens(pscriptParser::SEMI_COLON);
}

tree::TerminalNode* pscriptParser::Simple_stmtContext::SEMI_COLON(size_t i) {
  return getToken(pscriptParser::SEMI_COLON, i);
}


size_t pscriptParser::Simple_stmtContext::getRuleIndex() const {
  return pscriptParser::RuleSimple_stmt;
}

void pscriptParser::Simple_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_stmt(this);
}

void pscriptParser::Simple_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_stmt(this);
}


std::any pscriptParser::Simple_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitSimple_stmt(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Simple_stmtContext* pscriptParser::simple_stmt() {
  Simple_stmtContext *_localctx = _tracker.createInstance<Simple_stmtContext>(_ctx, getState());
  enterRule(_localctx, 42, pscriptParser::RuleSimple_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(377);
    small_stmt();
    setState(382);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(378);
        match(pscriptParser::SEMI_COLON);
        setState(379);
        small_stmt(); 
      }
      setState(384);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
    }
    setState(386);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::SEMI_COLON) {
      setState(385);
      match(pscriptParser::SEMI_COLON);
    }
    setState(388);
    _la = _input->LA(1);
    if (!(_la == pscriptParser::EOF

    || _la == pscriptParser::LINE_BREAK)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Small_stmtContext ------------------------------------------------------------------

pscriptParser::Small_stmtContext::Small_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t pscriptParser::Small_stmtContext::getRuleIndex() const {
  return pscriptParser::RuleSmall_stmt;
}

void pscriptParser::Small_stmtContext::copyFrom(Small_stmtContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Assert_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Assert_stmtContext::ASSERT() {
  return getToken(pscriptParser::ASSERT, 0);
}

std::vector<pscriptParser::TestContext *> pscriptParser::Assert_stmtContext::test() {
  return getRuleContexts<pscriptParser::TestContext>();
}

pscriptParser::TestContext* pscriptParser::Assert_stmtContext::test(size_t i) {
  return getRuleContext<pscriptParser::TestContext>(i);
}

tree::TerminalNode* pscriptParser::Assert_stmtContext::COMMA() {
  return getToken(pscriptParser::COMMA, 0);
}

pscriptParser::Assert_stmtContext::Assert_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Assert_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssert_stmt(this);
}
void pscriptParser::Assert_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssert_stmt(this);
}

std::any pscriptParser::Assert_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitAssert_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Func_call_stmtContext ------------------------------------------------------------------

pscriptParser::AtomContext* pscriptParser::Func_call_stmtContext::atom() {
  return getRuleContext<pscriptParser::AtomContext>(0);
}

tree::TerminalNode* pscriptParser::Func_call_stmtContext::OPEN_PAREN() {
  return getToken(pscriptParser::OPEN_PAREN, 0);
}

tree::TerminalNode* pscriptParser::Func_call_stmtContext::CLOSE_PAREN() {
  return getToken(pscriptParser::CLOSE_PAREN, 0);
}

tree::TerminalNode* pscriptParser::Func_call_stmtContext::AWAIT() {
  return getToken(pscriptParser::AWAIT, 0);
}

pscriptParser::ArglistContext* pscriptParser::Func_call_stmtContext::arglist() {
  return getRuleContext<pscriptParser::ArglistContext>(0);
}

pscriptParser::Func_call_stmtContext::Func_call_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Func_call_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunc_call_stmt(this);
}
void pscriptParser::Func_call_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunc_call_stmt(this);
}

std::any pscriptParser::Func_call_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitFunc_call_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Nonlocal_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Nonlocal_stmtContext::NONLOCAL() {
  return getToken(pscriptParser::NONLOCAL, 0);
}

pscriptParser::Comma_nameContext* pscriptParser::Nonlocal_stmtContext::comma_name() {
  return getRuleContext<pscriptParser::Comma_nameContext>(0);
}

pscriptParser::Nonlocal_stmtContext::Nonlocal_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Nonlocal_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonlocal_stmt(this);
}
void pscriptParser::Nonlocal_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonlocal_stmt(this);
}

std::any pscriptParser::Nonlocal_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitNonlocal_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Pass_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Pass_stmtContext::PASS() {
  return getToken(pscriptParser::PASS, 0);
}

pscriptParser::Pass_stmtContext::Pass_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Pass_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPass_stmt(this);
}
void pscriptParser::Pass_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPass_stmt(this);
}

std::any pscriptParser::Pass_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitPass_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Variable_def_stmtContext ------------------------------------------------------------------

pscriptParser::Variable_defContext* pscriptParser::Variable_def_stmtContext::variable_def() {
  return getRuleContext<pscriptParser::Variable_defContext>(0);
}

pscriptParser::Variable_def_stmtContext::Variable_def_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Variable_def_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_def_stmt(this);
}
void pscriptParser::Variable_def_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_def_stmt(this);
}

std::any pscriptParser::Variable_def_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVariable_def_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Import_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Import_stmtContext::IMPORT() {
  return getToken(pscriptParser::IMPORT, 0);
}

pscriptParser::Name_as_namesContext* pscriptParser::Import_stmtContext::name_as_names() {
  return getRuleContext<pscriptParser::Name_as_namesContext>(0);
}

pscriptParser::Import_stmtContext::Import_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Import_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_stmt(this);
}
void pscriptParser::Import_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_stmt(this);
}

std::any pscriptParser::Import_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitImport_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- From_import_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::From_import_stmtContext::FROM() {
  return getToken(pscriptParser::FROM, 0);
}

pscriptParser::From_whereContext* pscriptParser::From_import_stmtContext::from_where() {
  return getRuleContext<pscriptParser::From_whereContext>(0);
}

tree::TerminalNode* pscriptParser::From_import_stmtContext::IMPORT() {
  return getToken(pscriptParser::IMPORT, 0);
}

tree::TerminalNode* pscriptParser::From_import_stmtContext::STAR() {
  return getToken(pscriptParser::STAR, 0);
}

tree::TerminalNode* pscriptParser::From_import_stmtContext::OPEN_PAREN() {
  return getToken(pscriptParser::OPEN_PAREN, 0);
}

pscriptParser::Import_as_namesContext* pscriptParser::From_import_stmtContext::import_as_names() {
  return getRuleContext<pscriptParser::Import_as_namesContext>(0);
}

tree::TerminalNode* pscriptParser::From_import_stmtContext::CLOSE_PAREN() {
  return getToken(pscriptParser::CLOSE_PAREN, 0);
}

pscriptParser::From_import_stmtContext::From_import_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::From_import_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_import_stmt(this);
}
void pscriptParser::From_import_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_import_stmt(this);
}

std::any pscriptParser::From_import_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitFrom_import_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Raise_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Raise_stmtContext::RAISE() {
  return getToken(pscriptParser::RAISE, 0);
}

pscriptParser::Comma_testContext* pscriptParser::Raise_stmtContext::comma_test() {
  return getRuleContext<pscriptParser::Comma_testContext>(0);
}

pscriptParser::Raise_stmtContext::Raise_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Raise_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaise_stmt(this);
}
void pscriptParser::Raise_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaise_stmt(this);
}

std::any pscriptParser::Raise_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitRaise_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Yield_stmtContext ------------------------------------------------------------------

pscriptParser::Yield_exprContext* pscriptParser::Yield_stmtContext::yield_expr() {
  return getRuleContext<pscriptParser::Yield_exprContext>(0);
}

pscriptParser::Yield_stmtContext::Yield_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Yield_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYield_stmt(this);
}
void pscriptParser::Yield_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYield_stmt(this);
}

std::any pscriptParser::Yield_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitYield_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Global_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Global_stmtContext::GLOBAL() {
  return getToken(pscriptParser::GLOBAL, 0);
}

pscriptParser::Comma_nameContext* pscriptParser::Global_stmtContext::comma_name() {
  return getRuleContext<pscriptParser::Comma_nameContext>(0);
}

pscriptParser::Global_stmtContext::Global_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Global_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal_stmt(this);
}
void pscriptParser::Global_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal_stmt(this);
}

std::any pscriptParser::Global_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitGlobal_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Continue_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Continue_stmtContext::CONTINUE() {
  return getToken(pscriptParser::CONTINUE, 0);
}

pscriptParser::Continue_stmtContext::Continue_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Continue_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinue_stmt(this);
}
void pscriptParser::Continue_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinue_stmt(this);
}

std::any pscriptParser::Continue_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitContinue_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Break_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Break_stmtContext::BREAK() {
  return getToken(pscriptParser::BREAK, 0);
}

pscriptParser::Break_stmtContext::Break_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Break_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreak_stmt(this);
}
void pscriptParser::Break_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreak_stmt(this);
}

std::any pscriptParser::Break_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitBreak_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Del_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Del_stmtContext::DEL() {
  return getToken(pscriptParser::DEL, 0);
}

pscriptParser::ExprlistContext* pscriptParser::Del_stmtContext::exprlist() {
  return getRuleContext<pscriptParser::ExprlistContext>(0);
}

pscriptParser::Del_stmtContext::Del_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Del_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDel_stmt(this);
}
void pscriptParser::Del_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDel_stmt(this);
}

std::any pscriptParser::Del_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitDel_stmt(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Return_stmtContext ------------------------------------------------------------------

tree::TerminalNode* pscriptParser::Return_stmtContext::RETURN() {
  return getToken(pscriptParser::RETURN, 0);
}

pscriptParser::TestlistContext* pscriptParser::Return_stmtContext::testlist() {
  return getRuleContext<pscriptParser::TestlistContext>(0);
}

pscriptParser::Return_stmtContext::Return_stmtContext(Small_stmtContext *ctx) { copyFrom(ctx); }

void pscriptParser::Return_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturn_stmt(this);
}
void pscriptParser::Return_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturn_stmt(this);
}

std::any pscriptParser::Return_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitReturn_stmt(this);
  else
    return visitor->visitChildren(this);
}
pscriptParser::Small_stmtContext* pscriptParser::small_stmt() {
  Small_stmtContext *_localctx = _tracker.createInstance<Small_stmtContext>(_ctx, getState());
  enterRule(_localctx, 44, pscriptParser::RuleSmall_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(438);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<pscriptParser::Variable_def_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(390);
      variable_def();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<pscriptParser::Func_call_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(392);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::AWAIT) {
        setState(391);
        match(pscriptParser::AWAIT);
      }
      setState(394);
      atom();
      setState(395);
      match(pscriptParser::OPEN_PAREN);
      setState(397);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2522632411344273408) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & 11007) != 0)) {
        setState(396);
        arglist();
      }
      setState(399);
      match(pscriptParser::CLOSE_PAREN);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<pscriptParser::Del_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(401);
      match(pscriptParser::DEL);
      setState(402);
      exprlist();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<pscriptParser::Pass_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(403);
      match(pscriptParser::PASS);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<pscriptParser::Break_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(404);
      match(pscriptParser::BREAK);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<pscriptParser::Continue_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(405);
      match(pscriptParser::CONTINUE);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<pscriptParser::Return_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(406);
      match(pscriptParser::RETURN);
      setState(408);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2522034277018763264) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & 11007) != 0)) {
        setState(407);
        testlist();
      }
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<pscriptParser::Raise_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(410);
      match(pscriptParser::RAISE);
      setState(412);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2522034277018763264) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & 11007) != 0)) {
        setState(411);
        comma_test();
      }
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<pscriptParser::Yield_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(414);
      yield_expr();
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<pscriptParser::Import_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(415);
      match(pscriptParser::IMPORT);
      setState(416);
      name_as_names();
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<pscriptParser::From_import_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(417);
      match(pscriptParser::FROM);
      setState(418);
      from_where();
      setState(419);
      match(pscriptParser::IMPORT);
      setState(426);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case pscriptParser::STAR: {
          setState(420);
          match(pscriptParser::STAR);
          break;
        }

        case pscriptParser::OPEN_PAREN: {
          setState(421);
          match(pscriptParser::OPEN_PAREN);
          setState(422);
          import_as_names();
          setState(423);
          match(pscriptParser::CLOSE_PAREN);
          break;
        }

        case pscriptParser::TRUE:
        case pscriptParser::FALSE:
        case pscriptParser::NAME: {
          setState(425);
          import_as_names();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<pscriptParser::Global_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 12);
      setState(428);
      match(pscriptParser::GLOBAL);
      setState(429);
      comma_name();
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<pscriptParser::Assert_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 13);
      setState(430);
      match(pscriptParser::ASSERT);
      setState(431);
      test();
      setState(434);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::COMMA) {
        setState(432);
        match(pscriptParser::COMMA);
        setState(433);
        test();
      }
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<pscriptParser::Nonlocal_stmtContext>(_localctx);
      enterOuterAlt(_localctx, 14);
      setState(436);
      match(pscriptParser::NONLOCAL);
      setState(437);
      comma_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_defContext ------------------------------------------------------------------

pscriptParser::Variable_defContext::Variable_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::Variable_def_consts_with_colonContext* pscriptParser::Variable_defContext::variable_def_consts_with_colon() {
  return getRuleContext<pscriptParser::Variable_def_consts_with_colonContext>(0);
}

pscriptParser::Variable_def_nameContext* pscriptParser::Variable_defContext::variable_def_name() {
  return getRuleContext<pscriptParser::Variable_def_nameContext>(0);
}

tree::TerminalNode* pscriptParser::Variable_defContext::SEMI_COLON() {
  return getToken(pscriptParser::SEMI_COLON, 0);
}

pscriptParser::Variable_def_constsContext* pscriptParser::Variable_defContext::variable_def_consts() {
  return getRuleContext<pscriptParser::Variable_def_constsContext>(0);
}

pscriptParser::Assign_partContext* pscriptParser::Variable_defContext::assign_part() {
  return getRuleContext<pscriptParser::Assign_partContext>(0);
}

pscriptParser::Variable_def_comma_nameContext* pscriptParser::Variable_defContext::variable_def_comma_name() {
  return getRuleContext<pscriptParser::Variable_def_comma_nameContext>(0);
}


size_t pscriptParser::Variable_defContext::getRuleIndex() const {
  return pscriptParser::RuleVariable_def;
}

void pscriptParser::Variable_defContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_def(this);
}

void pscriptParser::Variable_defContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_def(this);
}


std::any pscriptParser::Variable_defContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVariable_def(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Variable_defContext* pscriptParser::variable_def() {
  Variable_defContext *_localctx = _tracker.createInstance<Variable_defContext>(_ctx, getState());
  enterRule(_localctx, 46, pscriptParser::RuleVariable_def);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(458);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(440);
      variable_def_consts_with_colon();
      setState(441);
      variable_def_name();
      setState(442);
      match(pscriptParser::SEMI_COLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(444);
      variable_def_consts();
      setState(445);
      variable_def_name();
      setState(446);
      assign_part();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(448);
      variable_def_consts();
      setState(449);
      variable_def_comma_name();
      setState(450);
      assign_part();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(452);
      variable_def_name();
      setState(453);
      assign_part();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(455);
      variable_def_comma_name();
      setState(456);
      assign_part();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_def_nameContext ------------------------------------------------------------------

pscriptParser::Variable_def_nameContext::Variable_def_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::Dotted_nameContext* pscriptParser::Variable_def_nameContext::dotted_name() {
  return getRuleContext<pscriptParser::Dotted_nameContext>(0);
}

std::vector<tree::TerminalNode *> pscriptParser::Variable_def_nameContext::OPEN_BRACKET() {
  return getTokens(pscriptParser::OPEN_BRACKET);
}

tree::TerminalNode* pscriptParser::Variable_def_nameContext::OPEN_BRACKET(size_t i) {
  return getToken(pscriptParser::OPEN_BRACKET, i);
}

std::vector<pscriptParser::ExprContext *> pscriptParser::Variable_def_nameContext::expr() {
  return getRuleContexts<pscriptParser::ExprContext>();
}

pscriptParser::ExprContext* pscriptParser::Variable_def_nameContext::expr(size_t i) {
  return getRuleContext<pscriptParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::Variable_def_nameContext::CLOSE_BRACKET() {
  return getTokens(pscriptParser::CLOSE_BRACKET);
}

tree::TerminalNode* pscriptParser::Variable_def_nameContext::CLOSE_BRACKET(size_t i) {
  return getToken(pscriptParser::CLOSE_BRACKET, i);
}

tree::TerminalNode* pscriptParser::Variable_def_nameContext::DOT() {
  return getToken(pscriptParser::DOT, 0);
}

pscriptParser::Variable_def_nameContext* pscriptParser::Variable_def_nameContext::variable_def_name() {
  return getRuleContext<pscriptParser::Variable_def_nameContext>(0);
}


size_t pscriptParser::Variable_def_nameContext::getRuleIndex() const {
  return pscriptParser::RuleVariable_def_name;
}

void pscriptParser::Variable_def_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_def_name(this);
}

void pscriptParser::Variable_def_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_def_name(this);
}


std::any pscriptParser::Variable_def_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVariable_def_name(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Variable_def_nameContext* pscriptParser::variable_def_name() {
  Variable_def_nameContext *_localctx = _tracker.createInstance<Variable_def_nameContext>(_ctx, getState());
  enterRule(_localctx, 48, pscriptParser::RuleVariable_def_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(460);
    dotted_name(0);
    setState(467);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == pscriptParser::OPEN_BRACKET) {
      setState(461);
      match(pscriptParser::OPEN_BRACKET);
      setState(462);
      expr(0);
      setState(463);
      match(pscriptParser::CLOSE_BRACKET);
      setState(469);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(472);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::DOT) {
      setState(470);
      match(pscriptParser::DOT);
      setState(471);
      variable_def_name();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_def_comma_nameContext ------------------------------------------------------------------

pscriptParser::Variable_def_comma_nameContext::Variable_def_comma_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::Variable_def_nameContext *> pscriptParser::Variable_def_comma_nameContext::variable_def_name() {
  return getRuleContexts<pscriptParser::Variable_def_nameContext>();
}

pscriptParser::Variable_def_nameContext* pscriptParser::Variable_def_comma_nameContext::variable_def_name(size_t i) {
  return getRuleContext<pscriptParser::Variable_def_nameContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::Variable_def_comma_nameContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::Variable_def_comma_nameContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::Variable_def_comma_nameContext::getRuleIndex() const {
  return pscriptParser::RuleVariable_def_comma_name;
}

void pscriptParser::Variable_def_comma_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_def_comma_name(this);
}

void pscriptParser::Variable_def_comma_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_def_comma_name(this);
}


std::any pscriptParser::Variable_def_comma_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVariable_def_comma_name(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Variable_def_comma_nameContext* pscriptParser::variable_def_comma_name() {
  Variable_def_comma_nameContext *_localctx = _tracker.createInstance<Variable_def_comma_nameContext>(_ctx, getState());
  enterRule(_localctx, 50, pscriptParser::RuleVariable_def_comma_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(474);
    variable_def_name();
    setState(479);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == pscriptParser::COMMA) {
      setState(475);
      match(pscriptParser::COMMA);
      setState(476);
      variable_def_name();
      setState(481);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- From_whereContext ------------------------------------------------------------------

pscriptParser::From_whereContext::From_whereContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::Dotted_nameContext* pscriptParser::From_whereContext::dotted_name() {
  return getRuleContext<pscriptParser::Dotted_nameContext>(0);
}

std::vector<tree::TerminalNode *> pscriptParser::From_whereContext::DOT() {
  return getTokens(pscriptParser::DOT);
}

tree::TerminalNode* pscriptParser::From_whereContext::DOT(size_t i) {
  return getToken(pscriptParser::DOT, i);
}


size_t pscriptParser::From_whereContext::getRuleIndex() const {
  return pscriptParser::RuleFrom_where;
}

void pscriptParser::From_whereContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrom_where(this);
}

void pscriptParser::From_whereContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrom_where(this);
}


std::any pscriptParser::From_whereContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitFrom_where(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::From_whereContext* pscriptParser::from_where() {
  From_whereContext *_localctx = _tracker.createInstance<From_whereContext>(_ctx, getState());
  enterRule(_localctx, 52, pscriptParser::RuleFrom_where);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(494);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(485);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == pscriptParser::DOT) {
        setState(482);
        match(pscriptParser::DOT);
        setState(487);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(488);
      dotted_name(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(490); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(489);
        match(pscriptParser::DOT);
        setState(492); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == pscriptParser::DOT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comma_nameContext ------------------------------------------------------------------

pscriptParser::Comma_nameContext::Comma_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::Dotted_nameContext *> pscriptParser::Comma_nameContext::dotted_name() {
  return getRuleContexts<pscriptParser::Dotted_nameContext>();
}

pscriptParser::Dotted_nameContext* pscriptParser::Comma_nameContext::dotted_name(size_t i) {
  return getRuleContext<pscriptParser::Dotted_nameContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::Comma_nameContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::Comma_nameContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::Comma_nameContext::getRuleIndex() const {
  return pscriptParser::RuleComma_name;
}

void pscriptParser::Comma_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComma_name(this);
}

void pscriptParser::Comma_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComma_name(this);
}


std::any pscriptParser::Comma_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitComma_name(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Comma_nameContext* pscriptParser::comma_name() {
  Comma_nameContext *_localctx = _tracker.createInstance<Comma_nameContext>(_ctx, getState());
  enterRule(_localctx, 54, pscriptParser::RuleComma_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(496);
    dotted_name(0);
    setState(501);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == pscriptParser::COMMA) {
      setState(497);
      match(pscriptParser::COMMA);
      setState(498);
      dotted_name(0);
      setState(503);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comma_testContext ------------------------------------------------------------------

pscriptParser::Comma_testContext::Comma_testContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::TestContext *> pscriptParser::Comma_testContext::test() {
  return getRuleContexts<pscriptParser::TestContext>();
}

pscriptParser::TestContext* pscriptParser::Comma_testContext::test(size_t i) {
  return getRuleContext<pscriptParser::TestContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::Comma_testContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::Comma_testContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::Comma_testContext::getRuleIndex() const {
  return pscriptParser::RuleComma_test;
}

void pscriptParser::Comma_testContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComma_test(this);
}

void pscriptParser::Comma_testContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComma_test(this);
}


std::any pscriptParser::Comma_testContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitComma_test(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Comma_testContext* pscriptParser::comma_test() {
  Comma_testContext *_localctx = _tracker.createInstance<Comma_testContext>(_ctx, getState());
  enterRule(_localctx, 56, pscriptParser::RuleComma_test);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(504);
    test();
    setState(511);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::COMMA) {
      setState(505);
      match(pscriptParser::COMMA);
      setState(506);
      test();
      setState(509);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::COMMA) {
        setState(507);
        match(pscriptParser::COMMA);
        setState(508);
        test();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_def_constsContext ------------------------------------------------------------------

pscriptParser::Variable_def_constsContext::Variable_def_constsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Variable_def_constsContext::VAR() {
  return getToken(pscriptParser::VAR, 0);
}

tree::TerminalNode* pscriptParser::Variable_def_constsContext::CONST() {
  return getToken(pscriptParser::CONST, 0);
}

tree::TerminalNode* pscriptParser::Variable_def_constsContext::LET() {
  return getToken(pscriptParser::LET, 0);
}


size_t pscriptParser::Variable_def_constsContext::getRuleIndex() const {
  return pscriptParser::RuleVariable_def_consts;
}

void pscriptParser::Variable_def_constsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_def_consts(this);
}

void pscriptParser::Variable_def_constsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_def_consts(this);
}


std::any pscriptParser::Variable_def_constsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVariable_def_consts(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Variable_def_constsContext* pscriptParser::variable_def_consts() {
  Variable_def_constsContext *_localctx = _tracker.createInstance<Variable_def_constsContext>(_ctx, getState());
  enterRule(_localctx, 58, pscriptParser::RuleVariable_def_consts);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(513);
    antlrcpp::downCast<Variable_def_constsContext *>(_localctx)->variable_const = _input->LT(1);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 7696581394432) != 0))) {
      antlrcpp::downCast<Variable_def_constsContext *>(_localctx)->variable_const = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_def_consts_with_colonContext ------------------------------------------------------------------

pscriptParser::Variable_def_consts_with_colonContext::Variable_def_consts_with_colonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Variable_def_consts_with_colonContext::VAR() {
  return getToken(pscriptParser::VAR, 0);
}

tree::TerminalNode* pscriptParser::Variable_def_consts_with_colonContext::LET() {
  return getToken(pscriptParser::LET, 0);
}


size_t pscriptParser::Variable_def_consts_with_colonContext::getRuleIndex() const {
  return pscriptParser::RuleVariable_def_consts_with_colon;
}

void pscriptParser::Variable_def_consts_with_colonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_def_consts_with_colon(this);
}

void pscriptParser::Variable_def_consts_with_colonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_def_consts_with_colon(this);
}


std::any pscriptParser::Variable_def_consts_with_colonContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVariable_def_consts_with_colon(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Variable_def_consts_with_colonContext* pscriptParser::variable_def_consts_with_colon() {
  Variable_def_consts_with_colonContext *_localctx = _tracker.createInstance<Variable_def_consts_with_colonContext>(_ctx, getState());
  enterRule(_localctx, 60, pscriptParser::RuleVariable_def_consts_with_colon);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(515);
    antlrcpp::downCast<Variable_def_consts_with_colonContext *>(_localctx)->variable_const = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == pscriptParser::VAR

    || _la == pscriptParser::LET)) {
      antlrcpp::downCast<Variable_def_consts_with_colonContext *>(_localctx)->variable_const = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Testlist_star_exprContext ------------------------------------------------------------------

pscriptParser::Testlist_star_exprContext::Testlist_star_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::TestContext *> pscriptParser::Testlist_star_exprContext::test() {
  return getRuleContexts<pscriptParser::TestContext>();
}

pscriptParser::TestContext* pscriptParser::Testlist_star_exprContext::test(size_t i) {
  return getRuleContext<pscriptParser::TestContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::Testlist_star_exprContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::Testlist_star_exprContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}

pscriptParser::TestlistContext* pscriptParser::Testlist_star_exprContext::testlist() {
  return getRuleContext<pscriptParser::TestlistContext>(0);
}


size_t pscriptParser::Testlist_star_exprContext::getRuleIndex() const {
  return pscriptParser::RuleTestlist_star_expr;
}

void pscriptParser::Testlist_star_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTestlist_star_expr(this);
}

void pscriptParser::Testlist_star_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTestlist_star_expr(this);
}


std::any pscriptParser::Testlist_star_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitTestlist_star_expr(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Testlist_star_exprContext* pscriptParser::testlist_star_expr() {
  Testlist_star_exprContext *_localctx = _tracker.createInstance<Testlist_star_exprContext>(_ctx, getState());
  enterRule(_localctx, 62, pscriptParser::RuleTestlist_star_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(528);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(520); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(517);
                test();
                setState(518);
                match(pscriptParser::COMMA);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(522); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(525);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2522034277018763264) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & 11007) != 0)) {
        setState(524);
        test();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(527);
      testlist();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Star_exprContext ------------------------------------------------------------------

pscriptParser::Star_exprContext::Star_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Star_exprContext::STAR() {
  return getToken(pscriptParser::STAR, 0);
}

pscriptParser::ExprContext* pscriptParser::Star_exprContext::expr() {
  return getRuleContext<pscriptParser::ExprContext>(0);
}


size_t pscriptParser::Star_exprContext::getRuleIndex() const {
  return pscriptParser::RuleStar_expr;
}

void pscriptParser::Star_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStar_expr(this);
}

void pscriptParser::Star_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStar_expr(this);
}


std::any pscriptParser::Star_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitStar_expr(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Star_exprContext* pscriptParser::star_expr() {
  Star_exprContext *_localctx = _tracker.createInstance<Star_exprContext>(_ctx, getState());
  enterRule(_localctx, 64, pscriptParser::RuleStar_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(530);
    match(pscriptParser::STAR);
    setState(531);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assign_partContext ------------------------------------------------------------------

pscriptParser::Assign_partContext::Assign_partContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Assign_partContext::ASSIGN() {
  return getToken(pscriptParser::ASSIGN, 0);
}

tree::TerminalNode* pscriptParser::Assign_partContext::ADD_ASSIGN() {
  return getToken(pscriptParser::ADD_ASSIGN, 0);
}

tree::TerminalNode* pscriptParser::Assign_partContext::SUB_ASSIGN() {
  return getToken(pscriptParser::SUB_ASSIGN, 0);
}

tree::TerminalNode* pscriptParser::Assign_partContext::MULT_ASSIGN() {
  return getToken(pscriptParser::MULT_ASSIGN, 0);
}

tree::TerminalNode* pscriptParser::Assign_partContext::DIV_ASSIGN() {
  return getToken(pscriptParser::DIV_ASSIGN, 0);
}

tree::TerminalNode* pscriptParser::Assign_partContext::MOD_ASSIGN() {
  return getToken(pscriptParser::MOD_ASSIGN, 0);
}

tree::TerminalNode* pscriptParser::Assign_partContext::XOR_ASSIGN() {
  return getToken(pscriptParser::XOR_ASSIGN, 0);
}

tree::TerminalNode* pscriptParser::Assign_partContext::POWER_ASSIGN() {
  return getToken(pscriptParser::POWER_ASSIGN, 0);
}

tree::TerminalNode* pscriptParser::Assign_partContext::IDIV_ASSIGN() {
  return getToken(pscriptParser::IDIV_ASSIGN, 0);
}

pscriptParser::Yield_exprContext* pscriptParser::Assign_partContext::yield_expr() {
  return getRuleContext<pscriptParser::Yield_exprContext>(0);
}

pscriptParser::TestlistContext* pscriptParser::Assign_partContext::testlist() {
  return getRuleContext<pscriptParser::TestlistContext>(0);
}


size_t pscriptParser::Assign_partContext::getRuleIndex() const {
  return pscriptParser::RuleAssign_part;
}

void pscriptParser::Assign_partContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssign_part(this);
}

void pscriptParser::Assign_partContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssign_part(this);
}


std::any pscriptParser::Assign_partContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitAssign_part(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Assign_partContext* pscriptParser::assign_part() {
  Assign_partContext *_localctx = _tracker.createInstance<Assign_partContext>(_ctx, getState());
  enterRule(_localctx, 66, pscriptParser::RuleAssign_part);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(533);
    antlrcpp::downCast<Assign_partContext *>(_localctx)->op = _input->LT(1);
    _la = _input->LA(1);
    if (!(((((_la - 50) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 50)) & 534773761) != 0))) {
      antlrcpp::downCast<Assign_partContext *>(_localctx)->op = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(536);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::YIELD: {
        setState(534);
        yield_expr();
        break;
      }

      case pscriptParser::NONE:
      case pscriptParser::LAMBDA:
      case pscriptParser::NOT:
      case pscriptParser::AWAIT:
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::REVERSE_QUOTE:
      case pscriptParser::ADD:
      case pscriptParser::MINUS:
      case pscriptParser::NOT_OP:
      case pscriptParser::STRING:
      case pscriptParser::DECIMAL_INTEGER:
      case pscriptParser::OCT_INTEGER:
      case pscriptParser::HEX_INTEGER:
      case pscriptParser::BIN_INTEGER:
      case pscriptParser::IMAG_NUMBER:
      case pscriptParser::FLOAT_NUMBER:
      case pscriptParser::OPEN_PAREN:
      case pscriptParser::OPEN_BRACE:
      case pscriptParser::OPEN_BRACKET:
      case pscriptParser::NAME: {
        setState(535);
        testlist();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprlistContext ------------------------------------------------------------------

pscriptParser::ExprlistContext::ExprlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::ExprContext *> pscriptParser::ExprlistContext::expr() {
  return getRuleContexts<pscriptParser::ExprContext>();
}

pscriptParser::ExprContext* pscriptParser::ExprlistContext::expr(size_t i) {
  return getRuleContext<pscriptParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::ExprlistContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::ExprlistContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::ExprlistContext::getRuleIndex() const {
  return pscriptParser::RuleExprlist;
}

void pscriptParser::ExprlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprlist(this);
}

void pscriptParser::ExprlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprlist(this);
}


std::any pscriptParser::ExprlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitExprlist(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::ExprlistContext* pscriptParser::exprlist() {
  ExprlistContext *_localctx = _tracker.createInstance<ExprlistContext>(_ctx, getState());
  enterRule(_localctx, 68, pscriptParser::RuleExprlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(538);
    expr(0);
    setState(543);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(539);
        match(pscriptParser::COMMA);
        setState(540);
        expr(0); 
      }
      setState(545);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx);
    }
    setState(547);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::COMMA) {
      setState(546);
      match(pscriptParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_as_namesContext ------------------------------------------------------------------

pscriptParser::Import_as_namesContext::Import_as_namesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::Import_as_nameContext *> pscriptParser::Import_as_namesContext::import_as_name() {
  return getRuleContexts<pscriptParser::Import_as_nameContext>();
}

pscriptParser::Import_as_nameContext* pscriptParser::Import_as_namesContext::import_as_name(size_t i) {
  return getRuleContext<pscriptParser::Import_as_nameContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::Import_as_namesContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::Import_as_namesContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::Import_as_namesContext::getRuleIndex() const {
  return pscriptParser::RuleImport_as_names;
}

void pscriptParser::Import_as_namesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_as_names(this);
}

void pscriptParser::Import_as_namesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_as_names(this);
}


std::any pscriptParser::Import_as_namesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitImport_as_names(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Import_as_namesContext* pscriptParser::import_as_names() {
  Import_as_namesContext *_localctx = _tracker.createInstance<Import_as_namesContext>(_ctx, getState());
  enterRule(_localctx, 70, pscriptParser::RuleImport_as_names);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(549);
    import_as_name();
    setState(554);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(550);
        match(pscriptParser::COMMA);
        setState(551);
        import_as_name(); 
      }
      setState(556);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx);
    }
    setState(558);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::COMMA) {
      setState(557);
      match(pscriptParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_as_nameContext ------------------------------------------------------------------

pscriptParser::Import_as_nameContext::Import_as_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::NameContext *> pscriptParser::Import_as_nameContext::name() {
  return getRuleContexts<pscriptParser::NameContext>();
}

pscriptParser::NameContext* pscriptParser::Import_as_nameContext::name(size_t i) {
  return getRuleContext<pscriptParser::NameContext>(i);
}

tree::TerminalNode* pscriptParser::Import_as_nameContext::AS() {
  return getToken(pscriptParser::AS, 0);
}


size_t pscriptParser::Import_as_nameContext::getRuleIndex() const {
  return pscriptParser::RuleImport_as_name;
}

void pscriptParser::Import_as_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_as_name(this);
}

void pscriptParser::Import_as_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_as_name(this);
}


std::any pscriptParser::Import_as_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitImport_as_name(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Import_as_nameContext* pscriptParser::import_as_name() {
  Import_as_nameContext *_localctx = _tracker.createInstance<Import_as_nameContext>(_ctx, getState());
  enterRule(_localctx, 72, pscriptParser::RuleImport_as_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(560);
    name();
    setState(563);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::AS) {
      setState(561);
      match(pscriptParser::AS);
      setState(562);
      name();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_as_namesContext ------------------------------------------------------------------

pscriptParser::Name_as_namesContext::Name_as_namesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::Name_as_nameContext *> pscriptParser::Name_as_namesContext::name_as_name() {
  return getRuleContexts<pscriptParser::Name_as_nameContext>();
}

pscriptParser::Name_as_nameContext* pscriptParser::Name_as_namesContext::name_as_name(size_t i) {
  return getRuleContext<pscriptParser::Name_as_nameContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::Name_as_namesContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::Name_as_namesContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::Name_as_namesContext::getRuleIndex() const {
  return pscriptParser::RuleName_as_names;
}

void pscriptParser::Name_as_namesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName_as_names(this);
}

void pscriptParser::Name_as_namesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName_as_names(this);
}


std::any pscriptParser::Name_as_namesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitName_as_names(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Name_as_namesContext* pscriptParser::name_as_names() {
  Name_as_namesContext *_localctx = _tracker.createInstance<Name_as_namesContext>(_ctx, getState());
  enterRule(_localctx, 74, pscriptParser::RuleName_as_names);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(565);
    name_as_name();
    setState(570);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == pscriptParser::COMMA) {
      setState(566);
      match(pscriptParser::COMMA);
      setState(567);
      name_as_name();
      setState(572);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_as_nameContext ------------------------------------------------------------------

pscriptParser::Name_as_nameContext::Name_as_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::NameContext *> pscriptParser::Name_as_nameContext::name() {
  return getRuleContexts<pscriptParser::NameContext>();
}

pscriptParser::NameContext* pscriptParser::Name_as_nameContext::name(size_t i) {
  return getRuleContext<pscriptParser::NameContext>(i);
}

tree::TerminalNode* pscriptParser::Name_as_nameContext::AS() {
  return getToken(pscriptParser::AS, 0);
}


size_t pscriptParser::Name_as_nameContext::getRuleIndex() const {
  return pscriptParser::RuleName_as_name;
}

void pscriptParser::Name_as_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName_as_name(this);
}

void pscriptParser::Name_as_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName_as_name(this);
}


std::any pscriptParser::Name_as_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitName_as_name(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Name_as_nameContext* pscriptParser::name_as_name() {
  Name_as_nameContext *_localctx = _tracker.createInstance<Name_as_nameContext>(_ctx, getState());
  enterRule(_localctx, 76, pscriptParser::RuleName_as_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(573);
    name();
    setState(576);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::AS) {
      setState(574);
      match(pscriptParser::AS);
      setState(575);
      name();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TestContext ------------------------------------------------------------------

pscriptParser::TestContext::TestContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::Logical_testContext *> pscriptParser::TestContext::logical_test() {
  return getRuleContexts<pscriptParser::Logical_testContext>();
}

pscriptParser::Logical_testContext* pscriptParser::TestContext::logical_test(size_t i) {
  return getRuleContext<pscriptParser::Logical_testContext>(i);
}

tree::TerminalNode* pscriptParser::TestContext::IF() {
  return getToken(pscriptParser::IF, 0);
}

tree::TerminalNode* pscriptParser::TestContext::ELSE() {
  return getToken(pscriptParser::ELSE, 0);
}

pscriptParser::TestContext* pscriptParser::TestContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}

tree::TerminalNode* pscriptParser::TestContext::LAMBDA() {
  return getToken(pscriptParser::LAMBDA, 0);
}

tree::TerminalNode* pscriptParser::TestContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::VarargslistContext* pscriptParser::TestContext::varargslist() {
  return getRuleContext<pscriptParser::VarargslistContext>(0);
}


size_t pscriptParser::TestContext::getRuleIndex() const {
  return pscriptParser::RuleTest;
}

void pscriptParser::TestContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTest(this);
}

void pscriptParser::TestContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTest(this);
}


std::any pscriptParser::TestContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitTest(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::TestContext* pscriptParser::test() {
  TestContext *_localctx = _tracker.createInstance<TestContext>(_ctx, getState());
  enterRule(_localctx, 78, pscriptParser::RuleTest);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(592);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::NONE:
      case pscriptParser::NOT:
      case pscriptParser::AWAIT:
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::REVERSE_QUOTE:
      case pscriptParser::ADD:
      case pscriptParser::MINUS:
      case pscriptParser::NOT_OP:
      case pscriptParser::STRING:
      case pscriptParser::DECIMAL_INTEGER:
      case pscriptParser::OCT_INTEGER:
      case pscriptParser::HEX_INTEGER:
      case pscriptParser::BIN_INTEGER:
      case pscriptParser::IMAG_NUMBER:
      case pscriptParser::FLOAT_NUMBER:
      case pscriptParser::OPEN_PAREN:
      case pscriptParser::OPEN_BRACE:
      case pscriptParser::OPEN_BRACKET:
      case pscriptParser::NAME: {
        enterOuterAlt(_localctx, 1);
        setState(578);
        logical_test(0);
        setState(584);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
        case 1: {
          setState(579);
          match(pscriptParser::IF);
          setState(580);
          logical_test(0);
          setState(581);
          match(pscriptParser::ELSE);
          setState(582);
          test();
          break;
        }

        default:
          break;
        }
        break;
      }

      case pscriptParser::LAMBDA: {
        enterOuterAlt(_localctx, 2);
        setState(586);
        match(pscriptParser::LAMBDA);
        setState(588);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 38) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 38)) & 18014398509484163) != 0)) {
          setState(587);
          varargslist();
        }
        setState(590);
        match(pscriptParser::COLON);
        setState(591);
        test();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarargslistContext ------------------------------------------------------------------

pscriptParser::VarargslistContext::VarargslistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::VarargsContext* pscriptParser::VarargslistContext::varargs() {
  return getRuleContext<pscriptParser::VarargsContext>(0);
}

pscriptParser::VarkwargsContext* pscriptParser::VarargslistContext::varkwargs() {
  return getRuleContext<pscriptParser::VarkwargsContext>(0);
}

std::vector<pscriptParser::Vardef_parametersContext *> pscriptParser::VarargslistContext::vardef_parameters() {
  return getRuleContexts<pscriptParser::Vardef_parametersContext>();
}

pscriptParser::Vardef_parametersContext* pscriptParser::VarargslistContext::vardef_parameters(size_t i) {
  return getRuleContext<pscriptParser::Vardef_parametersContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::VarargslistContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::VarargslistContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::VarargslistContext::getRuleIndex() const {
  return pscriptParser::RuleVarargslist;
}

void pscriptParser::VarargslistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarargslist(this);
}

void pscriptParser::VarargslistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarargslist(this);
}


std::any pscriptParser::VarargslistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVarargslist(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::VarargslistContext* pscriptParser::varargslist() {
  VarargslistContext *_localctx = _tracker.createInstance<VarargslistContext>(_ctx, getState());
  enterRule(_localctx, 80, pscriptParser::RuleVarargslist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(618);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(597);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
      case 1: {
        setState(594);
        vardef_parameters();
        setState(595);
        match(pscriptParser::COMMA);
        break;
      }

      default:
        break;
      }
      setState(609);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case pscriptParser::STAR: {
          setState(599);
          varargs();
          setState(602);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
          case 1: {
            setState(600);
            match(pscriptParser::COMMA);
            setState(601);
            vardef_parameters();
            break;
          }

          default:
            break;
          }
          setState(606);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
          case 1: {
            setState(604);
            match(pscriptParser::COMMA);
            setState(605);
            varkwargs();
            break;
          }

          default:
            break;
          }
          break;
        }

        case pscriptParser::POWER: {
          setState(608);
          varkwargs();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(612);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::COMMA) {
        setState(611);
        match(pscriptParser::COMMA);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(614);
      vardef_parameters();
      setState(616);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::COMMA) {
        setState(615);
        match(pscriptParser::COMMA);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vardef_parametersContext ------------------------------------------------------------------

pscriptParser::Vardef_parametersContext::Vardef_parametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::Vardef_parameterContext *> pscriptParser::Vardef_parametersContext::vardef_parameter() {
  return getRuleContexts<pscriptParser::Vardef_parameterContext>();
}

pscriptParser::Vardef_parameterContext* pscriptParser::Vardef_parametersContext::vardef_parameter(size_t i) {
  return getRuleContext<pscriptParser::Vardef_parameterContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::Vardef_parametersContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::Vardef_parametersContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::Vardef_parametersContext::getRuleIndex() const {
  return pscriptParser::RuleVardef_parameters;
}

void pscriptParser::Vardef_parametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVardef_parameters(this);
}

void pscriptParser::Vardef_parametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVardef_parameters(this);
}


std::any pscriptParser::Vardef_parametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVardef_parameters(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Vardef_parametersContext* pscriptParser::vardef_parameters() {
  Vardef_parametersContext *_localctx = _tracker.createInstance<Vardef_parametersContext>(_ctx, getState());
  enterRule(_localctx, 82, pscriptParser::RuleVardef_parameters);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(620);
    vardef_parameter();
    setState(625);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(621);
        match(pscriptParser::COMMA);
        setState(622);
        vardef_parameter(); 
      }
      setState(627);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vardef_parameterContext ------------------------------------------------------------------

pscriptParser::Vardef_parameterContext::Vardef_parameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::NameContext* pscriptParser::Vardef_parameterContext::name() {
  return getRuleContext<pscriptParser::NameContext>(0);
}

tree::TerminalNode* pscriptParser::Vardef_parameterContext::ASSIGN() {
  return getToken(pscriptParser::ASSIGN, 0);
}

pscriptParser::TestContext* pscriptParser::Vardef_parameterContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}

tree::TerminalNode* pscriptParser::Vardef_parameterContext::STAR() {
  return getToken(pscriptParser::STAR, 0);
}


size_t pscriptParser::Vardef_parameterContext::getRuleIndex() const {
  return pscriptParser::RuleVardef_parameter;
}

void pscriptParser::Vardef_parameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVardef_parameter(this);
}

void pscriptParser::Vardef_parameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVardef_parameter(this);
}


std::any pscriptParser::Vardef_parameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVardef_parameter(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Vardef_parameterContext* pscriptParser::vardef_parameter() {
  Vardef_parameterContext *_localctx = _tracker.createInstance<Vardef_parameterContext>(_ctx, getState());
  enterRule(_localctx, 84, pscriptParser::RuleVardef_parameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(634);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::NAME: {
        enterOuterAlt(_localctx, 1);
        setState(628);
        name();
        setState(631);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == pscriptParser::ASSIGN) {
          setState(629);
          match(pscriptParser::ASSIGN);
          setState(630);
          test();
        }
        break;
      }

      case pscriptParser::STAR: {
        enterOuterAlt(_localctx, 2);
        setState(633);
        match(pscriptParser::STAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarargsContext ------------------------------------------------------------------

pscriptParser::VarargsContext::VarargsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::VarargsContext::STAR() {
  return getToken(pscriptParser::STAR, 0);
}

pscriptParser::NameContext* pscriptParser::VarargsContext::name() {
  return getRuleContext<pscriptParser::NameContext>(0);
}


size_t pscriptParser::VarargsContext::getRuleIndex() const {
  return pscriptParser::RuleVarargs;
}

void pscriptParser::VarargsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarargs(this);
}

void pscriptParser::VarargsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarargs(this);
}


std::any pscriptParser::VarargsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVarargs(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::VarargsContext* pscriptParser::varargs() {
  VarargsContext *_localctx = _tracker.createInstance<VarargsContext>(_ctx, getState());
  enterRule(_localctx, 86, pscriptParser::RuleVarargs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(636);
    match(pscriptParser::STAR);
    setState(637);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarkwargsContext ------------------------------------------------------------------

pscriptParser::VarkwargsContext::VarkwargsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::VarkwargsContext::POWER() {
  return getToken(pscriptParser::POWER, 0);
}

pscriptParser::NameContext* pscriptParser::VarkwargsContext::name() {
  return getRuleContext<pscriptParser::NameContext>(0);
}


size_t pscriptParser::VarkwargsContext::getRuleIndex() const {
  return pscriptParser::RuleVarkwargs;
}

void pscriptParser::VarkwargsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarkwargs(this);
}

void pscriptParser::VarkwargsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarkwargs(this);
}


std::any pscriptParser::VarkwargsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitVarkwargs(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::VarkwargsContext* pscriptParser::varkwargs() {
  VarkwargsContext *_localctx = _tracker.createInstance<VarkwargsContext>(_ctx, getState());
  enterRule(_localctx, 88, pscriptParser::RuleVarkwargs);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(639);
    match(pscriptParser::POWER);
    setState(640);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Logical_testContext ------------------------------------------------------------------

pscriptParser::Logical_testContext::Logical_testContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::ComparisonContext* pscriptParser::Logical_testContext::comparison() {
  return getRuleContext<pscriptParser::ComparisonContext>(0);
}

tree::TerminalNode* pscriptParser::Logical_testContext::NOT() {
  return getToken(pscriptParser::NOT, 0);
}

std::vector<pscriptParser::Logical_testContext *> pscriptParser::Logical_testContext::logical_test() {
  return getRuleContexts<pscriptParser::Logical_testContext>();
}

pscriptParser::Logical_testContext* pscriptParser::Logical_testContext::logical_test(size_t i) {
  return getRuleContext<pscriptParser::Logical_testContext>(i);
}

tree::TerminalNode* pscriptParser::Logical_testContext::AND() {
  return getToken(pscriptParser::AND, 0);
}

tree::TerminalNode* pscriptParser::Logical_testContext::OR() {
  return getToken(pscriptParser::OR, 0);
}


size_t pscriptParser::Logical_testContext::getRuleIndex() const {
  return pscriptParser::RuleLogical_test;
}

void pscriptParser::Logical_testContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogical_test(this);
}

void pscriptParser::Logical_testContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogical_test(this);
}


std::any pscriptParser::Logical_testContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitLogical_test(this);
  else
    return visitor->visitChildren(this);
}


pscriptParser::Logical_testContext* pscriptParser::logical_test() {
   return logical_test(0);
}

pscriptParser::Logical_testContext* pscriptParser::logical_test(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  pscriptParser::Logical_testContext *_localctx = _tracker.createInstance<Logical_testContext>(_ctx, parentState);
  pscriptParser::Logical_testContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 90;
  enterRecursionRule(_localctx, 90, pscriptParser::RuleLogical_test, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(646);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::NONE:
      case pscriptParser::AWAIT:
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::REVERSE_QUOTE:
      case pscriptParser::ADD:
      case pscriptParser::MINUS:
      case pscriptParser::NOT_OP:
      case pscriptParser::STRING:
      case pscriptParser::DECIMAL_INTEGER:
      case pscriptParser::OCT_INTEGER:
      case pscriptParser::HEX_INTEGER:
      case pscriptParser::BIN_INTEGER:
      case pscriptParser::IMAG_NUMBER:
      case pscriptParser::FLOAT_NUMBER:
      case pscriptParser::OPEN_PAREN:
      case pscriptParser::OPEN_BRACE:
      case pscriptParser::OPEN_BRACKET:
      case pscriptParser::NAME: {
        setState(643);
        comparison(0);
        break;
      }

      case pscriptParser::NOT: {
        setState(644);
        match(pscriptParser::NOT);
        setState(645);
        logical_test(3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(656);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(654);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Logical_testContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleLogical_test);
          setState(648);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(649);
          antlrcpp::downCast<Logical_testContext *>(_localctx)->op = match(pscriptParser::AND);
          setState(650);
          logical_test(3);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Logical_testContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleLogical_test);
          setState(651);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(652);
          antlrcpp::downCast<Logical_testContext *>(_localctx)->op = match(pscriptParser::OR);
          setState(653);
          logical_test(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(658);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ComparisonContext ------------------------------------------------------------------

pscriptParser::ComparisonContext::ComparisonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::ExprContext* pscriptParser::ComparisonContext::expr() {
  return getRuleContext<pscriptParser::ExprContext>(0);
}

std::vector<pscriptParser::ComparisonContext *> pscriptParser::ComparisonContext::comparison() {
  return getRuleContexts<pscriptParser::ComparisonContext>();
}

pscriptParser::ComparisonContext* pscriptParser::ComparisonContext::comparison(size_t i) {
  return getRuleContext<pscriptParser::ComparisonContext>(i);
}

tree::TerminalNode* pscriptParser::ComparisonContext::LESS_THAN() {
  return getToken(pscriptParser::LESS_THAN, 0);
}

tree::TerminalNode* pscriptParser::ComparisonContext::GREATER_THAN() {
  return getToken(pscriptParser::GREATER_THAN, 0);
}

tree::TerminalNode* pscriptParser::ComparisonContext::EQUALS() {
  return getToken(pscriptParser::EQUALS, 0);
}

tree::TerminalNode* pscriptParser::ComparisonContext::GT_EQ() {
  return getToken(pscriptParser::GT_EQ, 0);
}

tree::TerminalNode* pscriptParser::ComparisonContext::LT_EQ() {
  return getToken(pscriptParser::LT_EQ, 0);
}

tree::TerminalNode* pscriptParser::ComparisonContext::NOT_EQ_1() {
  return getToken(pscriptParser::NOT_EQ_1, 0);
}

tree::TerminalNode* pscriptParser::ComparisonContext::NOT_EQ_2() {
  return getToken(pscriptParser::NOT_EQ_2, 0);
}

tree::TerminalNode* pscriptParser::ComparisonContext::IN() {
  return getToken(pscriptParser::IN, 0);
}

tree::TerminalNode* pscriptParser::ComparisonContext::IS() {
  return getToken(pscriptParser::IS, 0);
}

tree::TerminalNode* pscriptParser::ComparisonContext::NOT() {
  return getToken(pscriptParser::NOT, 0);
}


size_t pscriptParser::ComparisonContext::getRuleIndex() const {
  return pscriptParser::RuleComparison;
}

void pscriptParser::ComparisonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparison(this);
}

void pscriptParser::ComparisonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparison(this);
}


std::any pscriptParser::ComparisonContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitComparison(this);
  else
    return visitor->visitChildren(this);
}


pscriptParser::ComparisonContext* pscriptParser::comparison() {
   return comparison(0);
}

pscriptParser::ComparisonContext* pscriptParser::comparison(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  pscriptParser::ComparisonContext *_localctx = _tracker.createInstance<ComparisonContext>(_ctx, parentState);
  pscriptParser::ComparisonContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 92;
  enterRecursionRule(_localctx, 92, pscriptParser::RuleComparison, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(660);
    expr(0);
    _ctx->stop = _input->LT(-1);
    setState(683);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<ComparisonContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleComparison);
        setState(662);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(678);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case pscriptParser::LESS_THAN: {
            setState(663);
            match(pscriptParser::LESS_THAN);
            break;
          }

          case pscriptParser::GREATER_THAN: {
            setState(664);
            match(pscriptParser::GREATER_THAN);
            break;
          }

          case pscriptParser::EQUALS: {
            setState(665);
            match(pscriptParser::EQUALS);
            break;
          }

          case pscriptParser::GT_EQ: {
            setState(666);
            match(pscriptParser::GT_EQ);
            break;
          }

          case pscriptParser::LT_EQ: {
            setState(667);
            match(pscriptParser::LT_EQ);
            break;
          }

          case pscriptParser::NOT_EQ_1: {
            setState(668);
            match(pscriptParser::NOT_EQ_1);
            break;
          }

          case pscriptParser::NOT_EQ_2: {
            setState(669);
            match(pscriptParser::NOT_EQ_2);
            break;
          }

          case pscriptParser::IN:
          case pscriptParser::NOT: {
            setState(671);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == pscriptParser::NOT) {
              setState(670);
              antlrcpp::downCast<ComparisonContext *>(_localctx)->optional = match(pscriptParser::NOT);
            }
            setState(673);
            match(pscriptParser::IN);
            break;
          }

          case pscriptParser::IS: {
            setState(674);
            match(pscriptParser::IS);
            setState(676);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == pscriptParser::NOT) {
              setState(675);
              antlrcpp::downCast<ComparisonContext *>(_localctx)->optional = match(pscriptParser::NOT);
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(680);
        comparison(3); 
      }
      setState(685);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

pscriptParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::AtomContext* pscriptParser::ExprContext::atom() {
  return getRuleContext<pscriptParser::AtomContext>(0);
}

tree::TerminalNode* pscriptParser::ExprContext::AWAIT() {
  return getToken(pscriptParser::AWAIT, 0);
}

std::vector<pscriptParser::TrailerContext *> pscriptParser::ExprContext::trailer() {
  return getRuleContexts<pscriptParser::TrailerContext>();
}

pscriptParser::TrailerContext* pscriptParser::ExprContext::trailer(size_t i) {
  return getRuleContext<pscriptParser::TrailerContext>(i);
}

std::vector<pscriptParser::ExprContext *> pscriptParser::ExprContext::expr() {
  return getRuleContexts<pscriptParser::ExprContext>();
}

pscriptParser::ExprContext* pscriptParser::ExprContext::expr(size_t i) {
  return getRuleContext<pscriptParser::ExprContext>(i);
}

tree::TerminalNode* pscriptParser::ExprContext::ADD() {
  return getToken(pscriptParser::ADD, 0);
}

tree::TerminalNode* pscriptParser::ExprContext::MINUS() {
  return getToken(pscriptParser::MINUS, 0);
}

tree::TerminalNode* pscriptParser::ExprContext::NOT_OP() {
  return getToken(pscriptParser::NOT_OP, 0);
}

tree::TerminalNode* pscriptParser::ExprContext::STAR() {
  return getToken(pscriptParser::STAR, 0);
}

tree::TerminalNode* pscriptParser::ExprContext::DIV() {
  return getToken(pscriptParser::DIV, 0);
}

tree::TerminalNode* pscriptParser::ExprContext::MOD() {
  return getToken(pscriptParser::MOD, 0);
}

tree::TerminalNode* pscriptParser::ExprContext::IDIV() {
  return getToken(pscriptParser::IDIV, 0);
}

tree::TerminalNode* pscriptParser::ExprContext::POWER() {
  return getToken(pscriptParser::POWER, 0);
}


size_t pscriptParser::ExprContext::getRuleIndex() const {
  return pscriptParser::RuleExpr;
}

void pscriptParser::ExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr(this);
}

void pscriptParser::ExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr(this);
}


std::any pscriptParser::ExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitExpr(this);
  else
    return visitor->visitChildren(this);
}


pscriptParser::ExprContext* pscriptParser::expr() {
   return expr(0);
}

pscriptParser::ExprContext* pscriptParser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  pscriptParser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  pscriptParser::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 94;
  enterRecursionRule(_localctx, 94, pscriptParser::RuleExpr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(699);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      setState(688);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::AWAIT) {
        setState(687);
        match(pscriptParser::AWAIT);
      }
      setState(690);
      atom();
      setState(694);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(691);
          trailer(); 
        }
        setState(696);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx);
      }
      break;
    }

    case 2: {
      setState(697);
      antlrcpp::downCast<ExprContext *>(_localctx)->op = _input->LT(1);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2522015791327477760) != 0))) {
        antlrcpp::downCast<ExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(698);
      expr(2);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(706);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleExpr);
        setState(701);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(702);
        antlrcpp::downCast<ExprContext *>(_localctx)->op = _input->LT(1);
        _la = _input->LA(1);
        if (!((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 2234383549501276160) != 0))) {
          antlrcpp::downCast<ExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(703);
        expr(2); 
      }
      setState(708);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- AtomContext ------------------------------------------------------------------

pscriptParser::AtomContext::AtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::AtomContext::OPEN_PAREN() {
  return getToken(pscriptParser::OPEN_PAREN, 0);
}

tree::TerminalNode* pscriptParser::AtomContext::CLOSE_PAREN() {
  return getToken(pscriptParser::CLOSE_PAREN, 0);
}

pscriptParser::Yield_exprContext* pscriptParser::AtomContext::yield_expr() {
  return getRuleContext<pscriptParser::Yield_exprContext>(0);
}

pscriptParser::TestlistContext* pscriptParser::AtomContext::testlist() {
  return getRuleContext<pscriptParser::TestlistContext>(0);
}

tree::TerminalNode* pscriptParser::AtomContext::OPEN_BRACKET() {
  return getToken(pscriptParser::OPEN_BRACKET, 0);
}

tree::TerminalNode* pscriptParser::AtomContext::CLOSE_BRACKET() {
  return getToken(pscriptParser::CLOSE_BRACKET, 0);
}

tree::TerminalNode* pscriptParser::AtomContext::OPEN_BRACE() {
  return getToken(pscriptParser::OPEN_BRACE, 0);
}

tree::TerminalNode* pscriptParser::AtomContext::CLOSE_BRACE() {
  return getToken(pscriptParser::CLOSE_BRACE, 0);
}

pscriptParser::DictmakerContext* pscriptParser::AtomContext::dictmaker() {
  return getRuleContext<pscriptParser::DictmakerContext>(0);
}

pscriptParser::SetmakerContext* pscriptParser::AtomContext::setmaker() {
  return getRuleContext<pscriptParser::SetmakerContext>(0);
}

std::vector<tree::TerminalNode *> pscriptParser::AtomContext::REVERSE_QUOTE() {
  return getTokens(pscriptParser::REVERSE_QUOTE);
}

tree::TerminalNode* pscriptParser::AtomContext::REVERSE_QUOTE(size_t i) {
  return getToken(pscriptParser::REVERSE_QUOTE, i);
}

tree::TerminalNode* pscriptParser::AtomContext::COMMA() {
  return getToken(pscriptParser::COMMA, 0);
}

pscriptParser::NameContext* pscriptParser::AtomContext::name() {
  return getRuleContext<pscriptParser::NameContext>(0);
}

pscriptParser::NumberContext* pscriptParser::AtomContext::number() {
  return getRuleContext<pscriptParser::NumberContext>(0);
}

tree::TerminalNode* pscriptParser::AtomContext::MINUS() {
  return getToken(pscriptParser::MINUS, 0);
}

tree::TerminalNode* pscriptParser::AtomContext::NONE() {
  return getToken(pscriptParser::NONE, 0);
}

std::vector<tree::TerminalNode *> pscriptParser::AtomContext::STRING() {
  return getTokens(pscriptParser::STRING);
}

tree::TerminalNode* pscriptParser::AtomContext::STRING(size_t i) {
  return getToken(pscriptParser::STRING, i);
}


size_t pscriptParser::AtomContext::getRuleIndex() const {
  return pscriptParser::RuleAtom;
}

void pscriptParser::AtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom(this);
}

void pscriptParser::AtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom(this);
}


std::any pscriptParser::AtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitAtom(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::AtomContext* pscriptParser::atom() {
  AtomContext *_localctx = _tracker.createInstance<AtomContext>(_ctx, getState());
  enterRule(_localctx, 96, pscriptParser::RuleAtom);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(747);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(709);
      match(pscriptParser::OPEN_PAREN);
      setState(712);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case pscriptParser::YIELD: {
          setState(710);
          yield_expr();
          break;
        }

        case pscriptParser::NONE:
        case pscriptParser::LAMBDA:
        case pscriptParser::NOT:
        case pscriptParser::AWAIT:
        case pscriptParser::TRUE:
        case pscriptParser::FALSE:
        case pscriptParser::REVERSE_QUOTE:
        case pscriptParser::ADD:
        case pscriptParser::MINUS:
        case pscriptParser::NOT_OP:
        case pscriptParser::STRING:
        case pscriptParser::DECIMAL_INTEGER:
        case pscriptParser::OCT_INTEGER:
        case pscriptParser::HEX_INTEGER:
        case pscriptParser::BIN_INTEGER:
        case pscriptParser::IMAG_NUMBER:
        case pscriptParser::FLOAT_NUMBER:
        case pscriptParser::OPEN_PAREN:
        case pscriptParser::OPEN_BRACE:
        case pscriptParser::OPEN_BRACKET:
        case pscriptParser::NAME: {
          setState(711);
          testlist();
          break;
        }

        case pscriptParser::CLOSE_PAREN: {
          break;
        }

      default:
        break;
      }
      setState(714);
      match(pscriptParser::CLOSE_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(715);
      match(pscriptParser::OPEN_BRACKET);
      setState(717);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2522034277018763264) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & 11007) != 0)) {
        setState(716);
        testlist();
      }
      setState(719);
      match(pscriptParser::CLOSE_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(720);
      match(pscriptParser::OPEN_BRACE);
      setState(722);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2522597226972184576) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & 11007) != 0)) {
        setState(721);
        dictmaker();
      }
      setState(724);
      match(pscriptParser::CLOSE_BRACE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(725);
      match(pscriptParser::OPEN_BRACE);
      setState(726);
      setmaker();
      setState(727);
      match(pscriptParser::CLOSE_BRACE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(729);
      match(pscriptParser::REVERSE_QUOTE);
      setState(730);
      testlist();
      setState(732);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::COMMA) {
        setState(731);
        match(pscriptParser::COMMA);
      }
      setState(734);
      match(pscriptParser::REVERSE_QUOTE);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(736);
      name();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(738);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == pscriptParser::MINUS) {
        setState(737);
        match(pscriptParser::MINUS);
      }
      setState(740);
      number();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(741);
      match(pscriptParser::NONE);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(743); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(742);
                match(pscriptParser::STRING);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(745); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DictmakerContext ------------------------------------------------------------------

pscriptParser::DictmakerContext::DictmakerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::TestContext *> pscriptParser::DictmakerContext::test() {
  return getRuleContexts<pscriptParser::TestContext>();
}

pscriptParser::TestContext* pscriptParser::DictmakerContext::test(size_t i) {
  return getRuleContext<pscriptParser::TestContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::DictmakerContext::COLON() {
  return getTokens(pscriptParser::COLON);
}

tree::TerminalNode* pscriptParser::DictmakerContext::COLON(size_t i) {
  return getToken(pscriptParser::COLON, i);
}

std::vector<tree::TerminalNode *> pscriptParser::DictmakerContext::POWER() {
  return getTokens(pscriptParser::POWER);
}

tree::TerminalNode* pscriptParser::DictmakerContext::POWER(size_t i) {
  return getToken(pscriptParser::POWER, i);
}

std::vector<pscriptParser::ExprContext *> pscriptParser::DictmakerContext::expr() {
  return getRuleContexts<pscriptParser::ExprContext>();
}

pscriptParser::ExprContext* pscriptParser::DictmakerContext::expr(size_t i) {
  return getRuleContext<pscriptParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::DictmakerContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::DictmakerContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::DictmakerContext::getRuleIndex() const {
  return pscriptParser::RuleDictmaker;
}

void pscriptParser::DictmakerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDictmaker(this);
}

void pscriptParser::DictmakerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDictmaker(this);
}


std::any pscriptParser::DictmakerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitDictmaker(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::DictmakerContext* pscriptParser::dictmaker() {
  DictmakerContext *_localctx = _tracker.createInstance<DictmakerContext>(_ctx, getState());
  enterRule(_localctx, 98, pscriptParser::RuleDictmaker);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(755);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::NONE:
      case pscriptParser::LAMBDA:
      case pscriptParser::NOT:
      case pscriptParser::AWAIT:
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::REVERSE_QUOTE:
      case pscriptParser::ADD:
      case pscriptParser::MINUS:
      case pscriptParser::NOT_OP:
      case pscriptParser::STRING:
      case pscriptParser::DECIMAL_INTEGER:
      case pscriptParser::OCT_INTEGER:
      case pscriptParser::HEX_INTEGER:
      case pscriptParser::BIN_INTEGER:
      case pscriptParser::IMAG_NUMBER:
      case pscriptParser::FLOAT_NUMBER:
      case pscriptParser::OPEN_PAREN:
      case pscriptParser::OPEN_BRACE:
      case pscriptParser::OPEN_BRACKET:
      case pscriptParser::NAME: {
        setState(749);
        test();
        setState(750);
        match(pscriptParser::COLON);
        setState(751);
        test();
        break;
      }

      case pscriptParser::POWER: {
        setState(753);
        match(pscriptParser::POWER);
        setState(754);
        expr(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(768);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(757);
        match(pscriptParser::COMMA);
        setState(764);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case pscriptParser::NONE:
          case pscriptParser::LAMBDA:
          case pscriptParser::NOT:
          case pscriptParser::AWAIT:
          case pscriptParser::TRUE:
          case pscriptParser::FALSE:
          case pscriptParser::REVERSE_QUOTE:
          case pscriptParser::ADD:
          case pscriptParser::MINUS:
          case pscriptParser::NOT_OP:
          case pscriptParser::STRING:
          case pscriptParser::DECIMAL_INTEGER:
          case pscriptParser::OCT_INTEGER:
          case pscriptParser::HEX_INTEGER:
          case pscriptParser::BIN_INTEGER:
          case pscriptParser::IMAG_NUMBER:
          case pscriptParser::FLOAT_NUMBER:
          case pscriptParser::OPEN_PAREN:
          case pscriptParser::OPEN_BRACE:
          case pscriptParser::OPEN_BRACKET:
          case pscriptParser::NAME: {
            setState(758);
            test();
            setState(759);
            match(pscriptParser::COLON);
            setState(760);
            test();
            break;
          }

          case pscriptParser::POWER: {
            setState(762);
            match(pscriptParser::POWER);
            setState(763);
            expr(0);
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(770);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx);
    }
    setState(772);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::COMMA) {
      setState(771);
      match(pscriptParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetmakerContext ------------------------------------------------------------------

pscriptParser::SetmakerContext::SetmakerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::TestlistContext* pscriptParser::SetmakerContext::testlist() {
  return getRuleContext<pscriptParser::TestlistContext>(0);
}


size_t pscriptParser::SetmakerContext::getRuleIndex() const {
  return pscriptParser::RuleSetmaker;
}

void pscriptParser::SetmakerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetmaker(this);
}

void pscriptParser::SetmakerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetmaker(this);
}


std::any pscriptParser::SetmakerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitSetmaker(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::SetmakerContext* pscriptParser::setmaker() {
  SetmakerContext *_localctx = _tracker.createInstance<SetmakerContext>(_ctx, getState());
  enterRule(_localctx, 100, pscriptParser::RuleSetmaker);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(774);
    testlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TestlistContext ------------------------------------------------------------------

pscriptParser::TestlistContext::TestlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::TestContext *> pscriptParser::TestlistContext::test() {
  return getRuleContexts<pscriptParser::TestContext>();
}

pscriptParser::TestContext* pscriptParser::TestlistContext::test(size_t i) {
  return getRuleContext<pscriptParser::TestContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::TestlistContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::TestlistContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::TestlistContext::getRuleIndex() const {
  return pscriptParser::RuleTestlist;
}

void pscriptParser::TestlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTestlist(this);
}

void pscriptParser::TestlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTestlist(this);
}


std::any pscriptParser::TestlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitTestlist(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::TestlistContext* pscriptParser::testlist() {
  TestlistContext *_localctx = _tracker.createInstance<TestlistContext>(_ctx, getState());
  enterRule(_localctx, 102, pscriptParser::RuleTestlist);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(776);
    test();
    setState(781);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(777);
        match(pscriptParser::COMMA);
        setState(778);
        test(); 
      }
      setState(783);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dotted_nameContext ------------------------------------------------------------------

pscriptParser::Dotted_nameContext::Dotted_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::NameContext* pscriptParser::Dotted_nameContext::name() {
  return getRuleContext<pscriptParser::NameContext>(0);
}

pscriptParser::Dotted_nameContext* pscriptParser::Dotted_nameContext::dotted_name() {
  return getRuleContext<pscriptParser::Dotted_nameContext>(0);
}

tree::TerminalNode* pscriptParser::Dotted_nameContext::DOT() {
  return getToken(pscriptParser::DOT, 0);
}


size_t pscriptParser::Dotted_nameContext::getRuleIndex() const {
  return pscriptParser::RuleDotted_name;
}

void pscriptParser::Dotted_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDotted_name(this);
}

void pscriptParser::Dotted_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDotted_name(this);
}


std::any pscriptParser::Dotted_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitDotted_name(this);
  else
    return visitor->visitChildren(this);
}


pscriptParser::Dotted_nameContext* pscriptParser::dotted_name() {
   return dotted_name(0);
}

pscriptParser::Dotted_nameContext* pscriptParser::dotted_name(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  pscriptParser::Dotted_nameContext *_localctx = _tracker.createInstance<Dotted_nameContext>(_ctx, parentState);
  pscriptParser::Dotted_nameContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 104;
  enterRecursionRule(_localctx, 104, pscriptParser::RuleDotted_name, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(785);
    name();
    _ctx->stop = _input->LT(-1);
    setState(792);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<Dotted_nameContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleDotted_name);
        setState(787);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(788);
        match(pscriptParser::DOT);
        setState(789);
        name(); 
      }
      setState(794);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- NameContext ------------------------------------------------------------------

pscriptParser::NameContext::NameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::NameContext::NAME() {
  return getToken(pscriptParser::NAME, 0);
}

pscriptParser::BoolContext* pscriptParser::NameContext::bool_() {
  return getRuleContext<pscriptParser::BoolContext>(0);
}


size_t pscriptParser::NameContext::getRuleIndex() const {
  return pscriptParser::RuleName;
}

void pscriptParser::NameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName(this);
}

void pscriptParser::NameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName(this);
}


std::any pscriptParser::NameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitName(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::NameContext* pscriptParser::name() {
  NameContext *_localctx = _tracker.createInstance<NameContext>(_ctx, getState());
  enterRule(_localctx, 106, pscriptParser::RuleName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(797);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::NAME: {
        enterOuterAlt(_localctx, 1);
        setState(795);
        match(pscriptParser::NAME);
        break;
      }

      case pscriptParser::TRUE:
      case pscriptParser::FALSE: {
        enterOuterAlt(_localctx, 2);
        setState(796);
        bool_();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BoolContext ------------------------------------------------------------------

pscriptParser::BoolContext::BoolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::BoolContext::TRUE() {
  return getToken(pscriptParser::TRUE, 0);
}

tree::TerminalNode* pscriptParser::BoolContext::FALSE() {
  return getToken(pscriptParser::FALSE, 0);
}


size_t pscriptParser::BoolContext::getRuleIndex() const {
  return pscriptParser::RuleBool;
}

void pscriptParser::BoolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool(this);
}

void pscriptParser::BoolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool(this);
}


std::any pscriptParser::BoolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitBool(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::BoolContext* pscriptParser::bool_() {
  BoolContext *_localctx = _tracker.createInstance<BoolContext>(_ctx, getState());
  enterRule(_localctx, 108, pscriptParser::RuleBool);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(799);
    _la = _input->LA(1);
    if (!(_la == pscriptParser::TRUE

    || _la == pscriptParser::FALSE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

pscriptParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::IntegerContext* pscriptParser::NumberContext::integer() {
  return getRuleContext<pscriptParser::IntegerContext>(0);
}

tree::TerminalNode* pscriptParser::NumberContext::IMAG_NUMBER() {
  return getToken(pscriptParser::IMAG_NUMBER, 0);
}

tree::TerminalNode* pscriptParser::NumberContext::FLOAT_NUMBER() {
  return getToken(pscriptParser::FLOAT_NUMBER, 0);
}


size_t pscriptParser::NumberContext::getRuleIndex() const {
  return pscriptParser::RuleNumber;
}

void pscriptParser::NumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumber(this);
}

void pscriptParser::NumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumber(this);
}


std::any pscriptParser::NumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitNumber(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::NumberContext* pscriptParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 110, pscriptParser::RuleNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(804);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::DECIMAL_INTEGER:
      case pscriptParser::OCT_INTEGER:
      case pscriptParser::HEX_INTEGER:
      case pscriptParser::BIN_INTEGER: {
        enterOuterAlt(_localctx, 1);
        setState(801);
        integer();
        break;
      }

      case pscriptParser::IMAG_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(802);
        match(pscriptParser::IMAG_NUMBER);
        break;
      }

      case pscriptParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 3);
        setState(803);
        match(pscriptParser::FLOAT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntegerContext ------------------------------------------------------------------

pscriptParser::IntegerContext::IntegerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::IntegerContext::DECIMAL_INTEGER() {
  return getToken(pscriptParser::DECIMAL_INTEGER, 0);
}

tree::TerminalNode* pscriptParser::IntegerContext::OCT_INTEGER() {
  return getToken(pscriptParser::OCT_INTEGER, 0);
}

tree::TerminalNode* pscriptParser::IntegerContext::HEX_INTEGER() {
  return getToken(pscriptParser::HEX_INTEGER, 0);
}

tree::TerminalNode* pscriptParser::IntegerContext::BIN_INTEGER() {
  return getToken(pscriptParser::BIN_INTEGER, 0);
}


size_t pscriptParser::IntegerContext::getRuleIndex() const {
  return pscriptParser::RuleInteger;
}

void pscriptParser::IntegerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInteger(this);
}

void pscriptParser::IntegerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInteger(this);
}


std::any pscriptParser::IntegerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitInteger(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::IntegerContext* pscriptParser::integer() {
  IntegerContext *_localctx = _tracker.createInstance<IntegerContext>(_ctx, getState());
  enterRule(_localctx, 112, pscriptParser::RuleInteger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(806);
    _la = _input->LA(1);
    if (!(((((_la - 80) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 80)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Yield_exprContext ------------------------------------------------------------------

pscriptParser::Yield_exprContext::Yield_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Yield_exprContext::YIELD() {
  return getToken(pscriptParser::YIELD, 0);
}

pscriptParser::Yield_argContext* pscriptParser::Yield_exprContext::yield_arg() {
  return getRuleContext<pscriptParser::Yield_argContext>(0);
}


size_t pscriptParser::Yield_exprContext::getRuleIndex() const {
  return pscriptParser::RuleYield_expr;
}

void pscriptParser::Yield_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYield_expr(this);
}

void pscriptParser::Yield_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYield_expr(this);
}


std::any pscriptParser::Yield_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitYield_expr(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Yield_exprContext* pscriptParser::yield_expr() {
  Yield_exprContext *_localctx = _tracker.createInstance<Yield_exprContext>(_ctx, getState());
  enterRule(_localctx, 114, pscriptParser::RuleYield_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(808);
    match(pscriptParser::YIELD);
    setState(810);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2522034277018763264) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & 11007) != 0)) {
      setState(809);
      yield_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Yield_argContext ------------------------------------------------------------------

pscriptParser::Yield_argContext::Yield_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::TestlistContext* pscriptParser::Yield_argContext::testlist() {
  return getRuleContext<pscriptParser::TestlistContext>(0);
}


size_t pscriptParser::Yield_argContext::getRuleIndex() const {
  return pscriptParser::RuleYield_arg;
}

void pscriptParser::Yield_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYield_arg(this);
}

void pscriptParser::Yield_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYield_arg(this);
}


std::any pscriptParser::Yield_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitYield_arg(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Yield_argContext* pscriptParser::yield_arg() {
  Yield_argContext *_localctx = _tracker.createInstance<Yield_argContext>(_ctx, getState());
  enterRule(_localctx, 116, pscriptParser::RuleYield_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(812);
    testlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TrailerContext ------------------------------------------------------------------

pscriptParser::TrailerContext::TrailerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::TrailerContext::DOT() {
  return getToken(pscriptParser::DOT, 0);
}

pscriptParser::NameContext* pscriptParser::TrailerContext::name() {
  return getRuleContext<pscriptParser::NameContext>(0);
}

pscriptParser::ArgumentsContext* pscriptParser::TrailerContext::arguments() {
  return getRuleContext<pscriptParser::ArgumentsContext>(0);
}


size_t pscriptParser::TrailerContext::getRuleIndex() const {
  return pscriptParser::RuleTrailer;
}

void pscriptParser::TrailerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrailer(this);
}

void pscriptParser::TrailerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrailer(this);
}


std::any pscriptParser::TrailerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitTrailer(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::TrailerContext* pscriptParser::trailer() {
  TrailerContext *_localctx = _tracker.createInstance<TrailerContext>(_ctx, getState());
  enterRule(_localctx, 118, pscriptParser::RuleTrailer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(820);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::DOT: {
        enterOuterAlt(_localctx, 1);
        setState(814);
        match(pscriptParser::DOT);
        setState(815);
        name();
        setState(817);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
        case 1: {
          setState(816);
          arguments();
          break;
        }

        default:
          break;
        }
        break;
      }

      case pscriptParser::OPEN_PAREN:
      case pscriptParser::OPEN_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(819);
        arguments();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

pscriptParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::ArgumentsContext::OPEN_PAREN() {
  return getToken(pscriptParser::OPEN_PAREN, 0);
}

tree::TerminalNode* pscriptParser::ArgumentsContext::CLOSE_PAREN() {
  return getToken(pscriptParser::CLOSE_PAREN, 0);
}

pscriptParser::ArglistContext* pscriptParser::ArgumentsContext::arglist() {
  return getRuleContext<pscriptParser::ArglistContext>(0);
}

tree::TerminalNode* pscriptParser::ArgumentsContext::OPEN_BRACKET() {
  return getToken(pscriptParser::OPEN_BRACKET, 0);
}

pscriptParser::SubscriptlistContext* pscriptParser::ArgumentsContext::subscriptlist() {
  return getRuleContext<pscriptParser::SubscriptlistContext>(0);
}

tree::TerminalNode* pscriptParser::ArgumentsContext::CLOSE_BRACKET() {
  return getToken(pscriptParser::CLOSE_BRACKET, 0);
}


size_t pscriptParser::ArgumentsContext::getRuleIndex() const {
  return pscriptParser::RuleArguments;
}

void pscriptParser::ArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArguments(this);
}

void pscriptParser::ArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArguments(this);
}


std::any pscriptParser::ArgumentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitArguments(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::ArgumentsContext* pscriptParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 120, pscriptParser::RuleArguments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(831);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 1);
        setState(822);
        match(pscriptParser::OPEN_PAREN);
        setState(824);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 2522632411344273408) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 79)) & 11007) != 0)) {
          setState(823);
          arglist();
        }
        setState(826);
        match(pscriptParser::CLOSE_PAREN);
        break;
      }

      case pscriptParser::OPEN_BRACKET: {
        enterOuterAlt(_localctx, 2);
        setState(827);
        match(pscriptParser::OPEN_BRACKET);
        setState(828);
        subscriptlist();
        setState(829);
        match(pscriptParser::CLOSE_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArglistContext ------------------------------------------------------------------

pscriptParser::ArglistContext::ArglistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::ArgumentContext *> pscriptParser::ArglistContext::argument() {
  return getRuleContexts<pscriptParser::ArgumentContext>();
}

pscriptParser::ArgumentContext* pscriptParser::ArglistContext::argument(size_t i) {
  return getRuleContext<pscriptParser::ArgumentContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::ArglistContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::ArglistContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::ArglistContext::getRuleIndex() const {
  return pscriptParser::RuleArglist;
}

void pscriptParser::ArglistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArglist(this);
}

void pscriptParser::ArglistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArglist(this);
}


std::any pscriptParser::ArglistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitArglist(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::ArglistContext* pscriptParser::arglist() {
  ArglistContext *_localctx = _tracker.createInstance<ArglistContext>(_ctx, getState());
  enterRule(_localctx, 122, pscriptParser::RuleArglist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(833);
    argument();
    setState(838);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(834);
        match(pscriptParser::COMMA);
        setState(835);
        argument(); 
      }
      setState(840);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
    }
    setState(842);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::COMMA) {
      setState(841);
      match(pscriptParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

pscriptParser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::TestContext *> pscriptParser::ArgumentContext::test() {
  return getRuleContexts<pscriptParser::TestContext>();
}

pscriptParser::TestContext* pscriptParser::ArgumentContext::test(size_t i) {
  return getRuleContext<pscriptParser::TestContext>(i);
}

tree::TerminalNode* pscriptParser::ArgumentContext::ASSIGN() {
  return getToken(pscriptParser::ASSIGN, 0);
}

tree::TerminalNode* pscriptParser::ArgumentContext::POWER() {
  return getToken(pscriptParser::POWER, 0);
}

tree::TerminalNode* pscriptParser::ArgumentContext::STAR() {
  return getToken(pscriptParser::STAR, 0);
}


size_t pscriptParser::ArgumentContext::getRuleIndex() const {
  return pscriptParser::RuleArgument;
}

void pscriptParser::ArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument(this);
}

void pscriptParser::ArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument(this);
}


std::any pscriptParser::ArgumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitArgument(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::ArgumentContext* pscriptParser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 124, pscriptParser::RuleArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(851);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::NONE:
      case pscriptParser::LAMBDA:
      case pscriptParser::NOT:
      case pscriptParser::AWAIT:
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::REVERSE_QUOTE:
      case pscriptParser::ADD:
      case pscriptParser::MINUS:
      case pscriptParser::NOT_OP:
      case pscriptParser::STRING:
      case pscriptParser::DECIMAL_INTEGER:
      case pscriptParser::OCT_INTEGER:
      case pscriptParser::HEX_INTEGER:
      case pscriptParser::BIN_INTEGER:
      case pscriptParser::IMAG_NUMBER:
      case pscriptParser::FLOAT_NUMBER:
      case pscriptParser::OPEN_PAREN:
      case pscriptParser::OPEN_BRACE:
      case pscriptParser::OPEN_BRACKET:
      case pscriptParser::NAME: {
        enterOuterAlt(_localctx, 1);
        setState(844);
        test();
        setState(847);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == pscriptParser::ASSIGN) {
          setState(845);
          match(pscriptParser::ASSIGN);
          setState(846);
          test();
        }
        break;
      }

      case pscriptParser::STAR:
      case pscriptParser::POWER: {
        enterOuterAlt(_localctx, 2);
        setState(849);
        _la = _input->LA(1);
        if (!(_la == pscriptParser::STAR

        || _la == pscriptParser::POWER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(850);
        test();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubscriptlistContext ------------------------------------------------------------------

pscriptParser::SubscriptlistContext::SubscriptlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::SubscriptContext *> pscriptParser::SubscriptlistContext::subscript() {
  return getRuleContexts<pscriptParser::SubscriptContext>();
}

pscriptParser::SubscriptContext* pscriptParser::SubscriptlistContext::subscript(size_t i) {
  return getRuleContext<pscriptParser::SubscriptContext>(i);
}

std::vector<tree::TerminalNode *> pscriptParser::SubscriptlistContext::COMMA() {
  return getTokens(pscriptParser::COMMA);
}

tree::TerminalNode* pscriptParser::SubscriptlistContext::COMMA(size_t i) {
  return getToken(pscriptParser::COMMA, i);
}


size_t pscriptParser::SubscriptlistContext::getRuleIndex() const {
  return pscriptParser::RuleSubscriptlist;
}

void pscriptParser::SubscriptlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscriptlist(this);
}

void pscriptParser::SubscriptlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscriptlist(this);
}


std::any pscriptParser::SubscriptlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitSubscriptlist(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::SubscriptlistContext* pscriptParser::subscriptlist() {
  SubscriptlistContext *_localctx = _tracker.createInstance<SubscriptlistContext>(_ctx, getState());
  enterRule(_localctx, 126, pscriptParser::RuleSubscriptlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(853);
    subscript();
    setState(858);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(854);
        match(pscriptParser::COMMA);
        setState(855);
        subscript(); 
      }
      setState(860);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx);
    }
    setState(862);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == pscriptParser::COMMA) {
      setState(861);
      match(pscriptParser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubscriptContext ------------------------------------------------------------------

pscriptParser::SubscriptContext::SubscriptContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<pscriptParser::TestContext *> pscriptParser::SubscriptContext::test() {
  return getRuleContexts<pscriptParser::TestContext>();
}

pscriptParser::TestContext* pscriptParser::SubscriptContext::test(size_t i) {
  return getRuleContext<pscriptParser::TestContext>(i);
}

tree::TerminalNode* pscriptParser::SubscriptContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::SliceopContext* pscriptParser::SubscriptContext::sliceop() {
  return getRuleContext<pscriptParser::SliceopContext>(0);
}


size_t pscriptParser::SubscriptContext::getRuleIndex() const {
  return pscriptParser::RuleSubscript;
}

void pscriptParser::SubscriptContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscript(this);
}

void pscriptParser::SubscriptContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscript(this);
}


std::any pscriptParser::SubscriptContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitSubscript(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::SubscriptContext* pscriptParser::subscript() {
  SubscriptContext *_localctx = _tracker.createInstance<SubscriptContext>(_ctx, getState());
  enterRule(_localctx, 128, pscriptParser::RuleSubscript);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(881);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::NONE:
      case pscriptParser::LAMBDA:
      case pscriptParser::NOT:
      case pscriptParser::AWAIT:
      case pscriptParser::TRUE:
      case pscriptParser::FALSE:
      case pscriptParser::REVERSE_QUOTE:
      case pscriptParser::ADD:
      case pscriptParser::MINUS:
      case pscriptParser::NOT_OP:
      case pscriptParser::STRING:
      case pscriptParser::DECIMAL_INTEGER:
      case pscriptParser::OCT_INTEGER:
      case pscriptParser::HEX_INTEGER:
      case pscriptParser::BIN_INTEGER:
      case pscriptParser::IMAG_NUMBER:
      case pscriptParser::FLOAT_NUMBER:
      case pscriptParser::OPEN_PAREN:
      case pscriptParser::OPEN_BRACE:
      case pscriptParser::OPEN_BRACKET:
      case pscriptParser::NAME: {
        enterOuterAlt(_localctx, 1);
        setState(864);
        test();
        setState(872);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == pscriptParser::COLON) {
          setState(865);
          match(pscriptParser::COLON);
          setState(867);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 2522034277018763264) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 79)) & 11007) != 0)) {
            setState(866);
            test();
          }
          setState(870);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == pscriptParser::COLON) {
            setState(869);
            sliceop();
          }
        }
        break;
      }

      case pscriptParser::COLON: {
        enterOuterAlt(_localctx, 2);
        setState(874);
        match(pscriptParser::COLON);
        setState(876);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 2522034277018763264) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 79)) & 11007) != 0)) {
          setState(875);
          test();
        }
        setState(879);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == pscriptParser::COLON) {
          setState(878);
          sliceop();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SliceopContext ------------------------------------------------------------------

pscriptParser::SliceopContext::SliceopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::SliceopContext::COLON() {
  return getToken(pscriptParser::COLON, 0);
}

pscriptParser::TestContext* pscriptParser::SliceopContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}


size_t pscriptParser::SliceopContext::getRuleIndex() const {
  return pscriptParser::RuleSliceop;
}

void pscriptParser::SliceopContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSliceop(this);
}

void pscriptParser::SliceopContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSliceop(this);
}


std::any pscriptParser::SliceopContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitSliceop(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::SliceopContext* pscriptParser::sliceop() {
  SliceopContext *_localctx = _tracker.createInstance<SliceopContext>(_ctx, getState());
  enterRule(_localctx, 130, pscriptParser::RuleSliceop);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(883);
    match(pscriptParser::COLON);
    setState(885);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2522034277018763264) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & 11007) != 0)) {
      setState(884);
      test();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_forContext ------------------------------------------------------------------

pscriptParser::Comp_forContext::Comp_forContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* pscriptParser::Comp_forContext::FOR() {
  return getToken(pscriptParser::FOR, 0);
}

pscriptParser::ExprlistContext* pscriptParser::Comp_forContext::exprlist() {
  return getRuleContext<pscriptParser::ExprlistContext>(0);
}

tree::TerminalNode* pscriptParser::Comp_forContext::IN() {
  return getToken(pscriptParser::IN, 0);
}

pscriptParser::Logical_testContext* pscriptParser::Comp_forContext::logical_test() {
  return getRuleContext<pscriptParser::Logical_testContext>(0);
}

pscriptParser::Comp_iterContext* pscriptParser::Comp_forContext::comp_iter() {
  return getRuleContext<pscriptParser::Comp_iterContext>(0);
}


size_t pscriptParser::Comp_forContext::getRuleIndex() const {
  return pscriptParser::RuleComp_for;
}

void pscriptParser::Comp_forContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComp_for(this);
}

void pscriptParser::Comp_forContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComp_for(this);
}


std::any pscriptParser::Comp_forContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitComp_for(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Comp_forContext* pscriptParser::comp_for() {
  Comp_forContext *_localctx = _tracker.createInstance<Comp_forContext>(_ctx, getState());
  enterRule(_localctx, 132, pscriptParser::RuleComp_for);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(887);
    match(pscriptParser::FOR);
    setState(888);
    exprlist();
    setState(889);
    match(pscriptParser::IN);
    setState(890);
    logical_test(0);
    setState(892);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
    case 1: {
      setState(891);
      comp_iter();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_iterContext ------------------------------------------------------------------

pscriptParser::Comp_iterContext::Comp_iterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

pscriptParser::Comp_forContext* pscriptParser::Comp_iterContext::comp_for() {
  return getRuleContext<pscriptParser::Comp_forContext>(0);
}

tree::TerminalNode* pscriptParser::Comp_iterContext::IF() {
  return getToken(pscriptParser::IF, 0);
}

pscriptParser::TestContext* pscriptParser::Comp_iterContext::test() {
  return getRuleContext<pscriptParser::TestContext>(0);
}

pscriptParser::Comp_iterContext* pscriptParser::Comp_iterContext::comp_iter() {
  return getRuleContext<pscriptParser::Comp_iterContext>(0);
}


size_t pscriptParser::Comp_iterContext::getRuleIndex() const {
  return pscriptParser::RuleComp_iter;
}

void pscriptParser::Comp_iterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComp_iter(this);
}

void pscriptParser::Comp_iterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<pscriptParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComp_iter(this);
}


std::any pscriptParser::Comp_iterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<pscriptParserVisitor*>(visitor))
    return parserVisitor->visitComp_iter(this);
  else
    return visitor->visitChildren(this);
}

pscriptParser::Comp_iterContext* pscriptParser::comp_iter() {
  Comp_iterContext *_localctx = _tracker.createInstance<Comp_iterContext>(_ctx, getState());
  enterRule(_localctx, 134, pscriptParser::RuleComp_iter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(900);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case pscriptParser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(894);
        comp_for();
        break;
      }

      case pscriptParser::IF: {
        enterOuterAlt(_localctx, 2);
        setState(895);
        match(pscriptParser::IF);
        setState(896);
        test();
        setState(898);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
        case 1: {
          setState(897);
          comp_iter();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool pscriptParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 45: return logical_testSempred(antlrcpp::downCast<Logical_testContext *>(context), predicateIndex);
    case 46: return comparisonSempred(antlrcpp::downCast<ComparisonContext *>(context), predicateIndex);
    case 47: return exprSempred(antlrcpp::downCast<ExprContext *>(context), predicateIndex);
    case 52: return dotted_nameSempred(antlrcpp::downCast<Dotted_nameContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool pscriptParser::logical_testSempred(Logical_testContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 2);
    case 1: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool pscriptParser::comparisonSempred(ComparisonContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool pscriptParser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 3: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool pscriptParser::dotted_nameSempred(Dotted_nameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

void pscriptParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  pscriptparserParserInitialize();
#else
  ::antlr4::internal::call_once(pscriptparserParserOnceFlag, pscriptparserParserInitialize);
#endif
}
